include "ADBase.template"

# number of spectra determined by (SPEC:SIZEX * SPEC:SIZEY) which is used to 
# set area detector ADMaxSizeX etc.

record(bi, "$(P)$(R)INTG:ENABLE")
{
    field(DESC, "Integrals Enabled")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))INTG_ENABLE")
    field(SCAN, "I/O Intr")
	field(ZNAM, "NO")
	field(ONAM, "YES")
	info(archive, "VAL")
}

record(bo, "$(P)$(R)INTG:ENABLE:SP")
{
    field(DESC, "Enable Integrals")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))INTG_ENABLE")
	field(PINI, "YES")
	field(ZNAM, "NO")
	field(ONAM, "YES")
    info(autosaveFields, "VAL")
}

record(mbbi, "$(P)$(R)INTG:MODE")
{
    field(DESC, "Integrals Mode")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))INTG_MODE")
    field(SCAN, "I/O Intr")
	field(ZRVL, 0)
	field(ONVL, 1)
	field(ZRST, "Total")
	field(ONST, "Difference")
	info(archive, "VAL")
}

record(mbbo, "$(P)$(R)INTG:MODE:SP")
{
    field(DESC, "Set Integrals Mode")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))INTG_MODE")
	field(PINI, "YES")
	field(ZRVL, 0)
	field(ONVL, 1)
	field(ZRST, "Total")
	field(ONST, "Difference")
    info(autosaveFields, "VAL")
}

record(mbbi, "$(P)$(R)INTG:DATAMODE")
{
    field(DESC, "Integrals Data Mode")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))INTG_DATA_MODE")
    field(SCAN, "I/O Intr")
	field(ZRVL, 0)
	field(ONVL, 1)
	field(ZRST, "TOFSummed")
	field(ONST, "TOFChannel")
	info(archive, "VAL")
}

record(mbbo, "$(P)$(R)INTG:DATAMODE:SP")
{
    field(DESC, "Set Integrals Data Mode")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))INTG_DATA_MODE")
	field(PINI, "YES")
	field(ZRVL, 0)
	field(ONVL, 1)
	field(ZRST, "TOFSummed")
	field(ONST, "TOFChannel")
    info(autosaveFields, "VAL")
}

record(longin, "$(P)$(R)INTG:SPEC:START")
{
    field(DESC, "Integrals Spec Start")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))INTG_SPEC_START")
    field(SCAN, "I/O Intr")
	info(archive, "VAL")
}

record(longout, "$(P)$(R)INTG:SPEC:START:SP")
{
    field(DESC, "Integrals Spec Start")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))INTG_SPEC_START")
	field(PINI, "YES")
    info(autosaveFields, "VAL")
}

## same as MaxSizeX_RBV
record(longin, "$(P)$(R)INTG:SPEC:SIZEX")
{
    field(DESC, "Integrals Spec X Size")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))MAX_SIZE_X")
    field(SCAN, "I/O Intr")
	info(archive, "VAL")
}

## The MaxSizeX parameter cannot be set from DB in normal areaDetector templates
record(longout, "$(P)$(R)INTG:SPEC:SIZEX:SP")
{
    field(DESC, "Integrals Spec X Size")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))MAX_SIZE_X")
	field(PINI, "YES")
    info(autosaveFields, "VAL")
}

## same as MaxSizeY_RBV
record(longin, "$(P)$(R)INTG:SPEC:SIZEY")
{
    field(DESC, "Integrals Spec Y Size")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))MAX_SIZE_Y")
    field(SCAN, "I/O Intr")
	info(archive, "VAL")
}

## The MaxSizeY parameter cannot be set from DB in normal areaDetector templates
record(longout, "$(P)$(R)INTG:SPEC:SIZEY:SP")
{
    field(DESC, "Integrals Spec Y Size")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))MAX_SIZE_Y")
	field(PINI, "YES")
    info(autosaveFields, "VAL")
}

record(ai, "$(P)$(R)INTG:TMIN")
{
    field(DESC, "Integrals TMIN")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))INTG_TMIN")
    field(SCAN, "I/O Intr")
	info(archive, "VAL")
}

record(ao, "$(P)$(R)INTG:TMIN:SP")
{
    field(DESC, "Set Integrals TMIN")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))INTG_TMIN")
	field(PINI, "YES")
    info(autosaveFields, "VAL")
}

record(ai, "$(P)$(R)INTG:TMAX")
{
    field(DESC, "Integrals TMAX")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))INTG_TMAX")
    field(SCAN, "I/O Intr")
	info(archive, "VAL")
}

record(ao, "$(P)$(R)INTG:TMAX:SP")
{
    field(DESC, "Set Integrals TMAX")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))INTG_TMAX")
	field(PINI, "YES")
    info(autosaveFields, "VAL")
}

record(ai, "$(P)$(R)INTG:UPD:RATE")
{
    field(DESC, "Integrals Update Rate")
	field(EGU, "Hz")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))INTG_UPD_RATE")
    field(SCAN, "I/O Intr")
}

record(ai, "$(P)$(R)INTG:RATE")
{
    field(DESC, "Live View Total Det Count Rate")
	field(EGU, "Hz")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))INTG_RATE")
    field(SCAN, "I/O Intr")
    info(INTEREST, "HIGH")
}

record(ai, "$(P)$(R)INTG:SPEC:RATE")
{
    field(DESC, "Live View Max Pixel Count Rate")
	field(EGU, "Hz")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))INTG_SPEC_RATE")
    field(SCAN, "I/O Intr")
    info(INTEREST, "HIGH")
}

record(ai, "$(P)$(R)INTG:SPEC:MAX")
{
    field(DESC, "Max Spec Value")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))INTG_SPEC_MAX")
    field(SCAN, "I/O Intr")
}

record(mbbi, "$(P)$(R)INTG:TRANS:MODE")
{
    field(DESC, "Integrals Trans Mode")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))INTG_TRANS_MODE")
    field(SCAN, "I/O Intr")
	field(ZRVL, 0)
	field(ONVL, 1)
	field(TWVL, 2)
	field(ZRST, "Linear")
	field(ONST, "Square Root")
	field(TWST, "Logarithmic")
	info(archive, "VAL")
}

record(mbbo, "$(P)$(R)INTG:TRANS:MODE:SP")
{
    field(DESC, "Integrals Trans Mode")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))INTG_TRANS_MODE")
	field(PINI, "YES")
	field(ZRVL, 0)
	field(ONVL, 1)
	field(TWVL, 2)
	field(ZRST, "Linear")
	field(ONST, "Square Root")
	field(TWST, "Logarithmic")
    info(autosaveFields, "VAL")
}
