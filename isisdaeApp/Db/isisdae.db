record(waveform, "$(P)$(Q)TITLE")
{
    field(DESC, "Run title")
    field(NELM, "256")
    field(FTVL, "CHAR")
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(icp,0,0)RUNTITLE")
    field(SCAN, "I/O Intr")
    info(INTEREST, "HIGH")
    info(archive, "VAL")
}

## can set DAEPINI to not process this if e.g. it is running with SECI 
record(waveform, "$(P)$(Q)TITLE:SP")
{
    field(DESC, "Set Run title")
    field(NELM, "256")
    field(FTVL, "CHAR")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(icp,0,0)RUNTITLESP")
    field(PINI, "$(DAEPINI=YES)")
    info(autosaveFields, "VAL")
}

record(bi, "$(P)$(Q)TITLE:DISPLAY")
{
    field(DESC, "Toggle Run Title Display")
    field(DTYP, "Soft Channel")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(SCAN, "Passive")
    info(archive, "VAL")
    info(autosaveFields, "VAL")
}

record(waveform, "$(P)$(Q)_HIDDEN")
{
    field(DESC, "waveform containing 'hidden'")
    field(NELM, "6")
    field(FTVL, "CHAR")
    field(INP, {const:[72,105,100,100,101,110]})
    field(ASG, "READONLY")
    field(DISP, "1")
}

record(acalcout, "$(P)$(Q)WDTITLE_CALC")
{
    field(NELM, "256")
    field(INPA, "$(P)$(Q)TITLE:DISPLAY CP")
    field(INBB, "$(P)$(Q)TITLE CP")
    field(INCC, "$(P)$(Q)_HIDDEN")
    field(CALC, "A?BB:CC")
    field(OUT, "$(P)$(Q)WDTITLE")
}

record(waveform, "$(P)$(Q)WDTITLE")
{
    field(DESC, "title displayed to web dashboard")
    field(NELM, "256")
    field(FTVL, "CHAR")
}

record(acalcout, "$(P)$(Q)WDUSERS_CALC")
{
    field(NELM, "1024")
    field(INPA, "$(P)$(Q)TITLE:DISPLAY CP")
    field(INBB, "$(P)$(Q)_USERNAME CP")
    field(INCC, "$(P)$(Q)_HIDDEN")
    field(CALC, "A?BB:CC")
    field(OUT, "$(P)$(Q)WDUSERS")
}

record(waveform, "$(P)$(Q)WDUSERS")
{
    field(DESC, "users displayed to web dashboard")
    field(NELM, "1024")
    field(FTVL, "CHAR")
}


alias("$(P)$(Q)TITLE", "$(P)$(Q)TITLE:SP:RBV")

record(stringin, "$(P)$(Q)_RBNUMBER")
{
    field(DESC, "Experiment (RB) Number")
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(icp,0,0)RBNUMBER")
    field(SCAN, "I/O Intr")
    field(VAL, "0")
    info(autosaveFields, "VAL")
    info(archive, "VAL")
}

record(stringout, "$(P)$(Q)_RBNUMBER:SP")
{
    field(DESC, "Set Experiment (RB) Number")
    field(DTYP, "asynOctetWrite")
    field(OUT,  "@asyn(icp,0,0)RBNUMBER")
    field(VAL, "0")
    info(autosaveFields, "VAL")
}

alias("$(P)$(Q)_RBNUMBER", "$(P)$(Q)_RBNUMBER:SP:RBV")

record(stringin, "$(P)$(Q)RUNNUMBER")
{
    field(DESC, "Run Number")
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(icp,0,0)RUNNUMBER")
    field(VAL, "0")
    field(SCAN, "I/O Intr")
    info(INTEREST, "HIGH")
    info(autosaveFields_pass0, "VAL")
    info(archive, "VAL")
}

record(longin, "$(P)$(Q)IRUNNUMBER")
{
    field(DESC, "Run Number")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(icp,0,0)IRUNNUMBER")
    field(SCAN, "I/O Intr")
    info(INTEREST, "MEDIUM")
    info(autosaveFields_pass0, "VAL")
	info(archive, "VAL")
	field(EGU, "")
}

## set run number: use with caution
## normally only used if we are syncing two instances
## if ibex on different computers
record(longout, "$(P)$(Q)RUNNUMBER:SET")
{
    field(DESC, "Set Run Number")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(icp,0,0)SET_RUNNUMBER")
	field(EGU, "")
}

record(waveform, "$(P)$(Q)_USERNAME")
{
    field(DESC, "Experiment User name")
    field(NELM, "1024")
    field(FTVL, "CHAR")
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(icp,0,0)USERNAME")
    field(SCAN, "I/O Intr")
    info(autosaveFields, "VAL")
    info(archive, "VAL")
}

record(waveform, "$(P)$(Q)_USERNAME:SP")
{
    field(DESC, "Set Experiment User name")
    field(NELM, "1024")
    field(FTVL, "CHAR")
    field(DTYP, "asynOctetWrite")
    field(INP, "@asyn(icp,0,0)USERNAME")
    info(autosaveFields, "VAL")
}

alias("$(P)$(Q)_USERNAME", "$(P)$(Q)_USERNAME:SP:RBV")

record(stringin, "$(P)$(Q)INSTNAME")
{
    field(DESC, "Instrument Name")
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(icp,0,0)INSTNAME")
    field(SCAN, "I/O Intr")
    info(INTEREST, "HIGH")
    info(autosaveFields, "VAL")
}

record(stringin, "$(P)$(Q)STARTTIME")
{
    field(DESC, "Run Start Time")
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(icp,0,0)STARTTIME")
    field(SCAN, "I/O Intr")
    info(INTEREST, "HIGH")
    info(archive, "VAL")
}

record(ai, "$(P)$(Q)NPRATIO")
{
    field(DESC, "Neutron/Proton ratio")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(icp,0,0)NPRATIO")
    field(SCAN, "I/O Intr")
	field(EGU, "")
    info(INTEREST, "HIGH")
}

record(stringin, "$(P)$(Q)DAETIMINGSOURCE")
{
    field(DESC, "DAE Timing Source")
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(icp,0,0)DAETIMINGSOURCE")
    field(SCAN, "I/O Intr")
    info(INTEREST, "HIGH")
    info(archive, "VAL")
}

record(stringin, "$(P)$(Q)PERIODTYPE")
{
    field(DESC, "DAE Period Type")
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(icp,0,0)PERIODTYPE")
    field(SCAN, "I/O Intr")
    info(INTEREST, "HIGH")
}

record(stringin, "$(P)$(Q)ISISCYCLE")
{
    field(DESC, "ISIS Run Cycle")
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(icp,0,0)ISISCYCLE")
    field(SCAN, "I/O Intr")
    info(INTEREST, "HIGH")
    info(autosaveFields, "VAL")
}

record(longin, "$(P)$(Q)RAWFRAMES")
{
    field(DESC, "Raw Frames")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(icp,0,0)RAWFRAMES")
    field(SCAN, "I/O Intr")
    info(INTEREST, "HIGH")
	field(EGU, "")
    info(archive, "-5.0 VAL")
}

record(longin, "$(P)$(Q)RAWFRAMES_PD")
{
    field(DESC, "Period Raw Frames")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(icp,0,0)RAWFRAMESPD")
    field(SCAN, "I/O Intr")
    info(archive, "-5.0 VAL")
}

record(longin, "$(P)$(Q)GOODFRAMES")
{
    field(DESC, "Good Frames")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(icp,0,0)GOODFRAMES")
    field(SCAN, "I/O Intr")
    info(INTEREST, "HIGH")
	field(EGU, "")
    info(archive, "-5.0 VAL")
}

record(longin, "$(P)$(Q)GOODFRAMES_PD")
{
    field(DESC, "Period Good Frames")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(icp,0,0)GOODFRAMESPD")
    field(SCAN, "I/O Intr")
    info(archive, "-5.0 VAL")
}

record(longin, "$(P)$(Q)RUNDURATION")
{
    field(DESC, "Run Duration")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(icp,0,0)RUNDURATION")
    field(SCAN, "I/O Intr")
    info(INTEREST, "HIGH")
    field(EGU, "s")
    info(archive, "-30.0 VAL")
}

record(calc, "$(P)$(Q)_RUNDURATION_H") {
    field(INPA, "$(P)$(Q)RUNDURATION CP MS")
    field(CALC, "FLOOR(A/3600)")
}

record(calc, "$(P)$(Q)_RUNDURATION_M") {
    field(INPA, "$(P)$(Q)RUNDURATION CP MS")
    field(CALC, "FLOOR(FLOOR(A%3600)/60)")
}

record(calc, "$(P)$(Q)_RUNDURATION_S") {
    field(INPA, "$(P)$(Q)RUNDURATION CP MS")
    field(CALC, "FLOOR(A%60)")
}

record(scalcout, "$(P)$(Q)_RUNDURATION_CALC") {
    field(INAA, "$(P)$(Q)_RUNDURATION_H")
    field(INBB, "$(P)$(Q)_RUNDURATION_M")
    field(INCC, "$(P)$(Q)_RUNDURATION_S")
    field(SCAN, "1 second")
    field(CALC, "PRINTF('%02d', AA)+':'+PRINTF('%02d', BB)+':'+PRINTF('%02d', CC)")
}

record(stringin, "$(P)$(Q)RUNDURATION_STR") {
    field(DESC, "Formatted Run Duration")
    field(INP, "$(P)$(Q)_RUNDURATION_CALC.SVAL CP MS")
}


record(longin, "$(P)$(Q)RUNDURATION_PD")
{
    field(DESC, "Period Run Duration")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(icp,0,0)RUNDURATIONPD")
    field(SCAN, "I/O Intr")
    field(EGU, "s")
    info(archive, "-30.0 VAL")
}

record(calc, "$(P)$(Q)_RUNDURATION_PD_H") {
    field(INPA, "$(P)$(Q)RUNDURATION_PD CP MS")
    field(CALC, "FLOOR(A/3600)")
}

record(calc, "$(P)$(Q)_RUNDURATION_PD_M") {
    field(INPA, "$(P)$(Q)RUNDURATION_PD CP MS")
    field(CALC, "FLOOR(FLOOR(A%3600)/60)")
}

record(calc, "$(P)$(Q)_RUNDURATION_PD_S") {
    field(INPA, "$(P)$(Q)RUNDURATION_PD CP MS")
    field(CALC, "FLOOR(A%60)")
}

record(scalcout, "$(P)$(Q)_RUNDURATION_PD_CALC") {
    field(INAA, "$(P)$(Q)_RUNDURATION_PD_H")
    field(INBB, "$(P)$(Q)_RUNDURATION_PD_M")
    field(INCC, "$(P)$(Q)_RUNDURATION_PD_S")
    field(SCAN, "1 second")
    field(CALC, "PRINTF('%02d', AA)+':'+PRINTF('%02d', BB)+':'+PRINTF('%02d', CC)")
}

record(stringin, "$(P)$(Q)RUNDURATION_PD_STR") {
    field(DESC, "Formatted Period Run Duration")
    field(INP, "$(P)$(Q)_RUNDURATION_PD_CALC.SVAL CP MS")
}


record(longin, "$(P)$(Q)NUMTIMECHANNELS")
{
    field(DESC, "Number of Histogram Time Channels")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(icp,0,0)NUMTIMECHANNELS")
    field(SCAN, "I/O Intr")
    info(INTEREST, "HIGH")
	field(EGU, "")
    info(archive, "VAL")
}

record(longin, "$(P)$(Q)DAEMEMORYUSED")
{
    field(DESC, "DAE Memory Used")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(icp,0,0)DAEMEMORYUSED")
    field(SCAN, "I/O Intr")
    info(INTEREST, "HIGH")
	field(EGU, "byte")
    info(archive, "VAL")
}

record(longin, "$(P)$(Q)NUMSPECTRA")
{
    field(DESC, "Number of DAE Spectra")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(icp,0,0)NUMSPECTRA")
    field(SCAN, "I/O Intr")
    info(INTEREST, "HIGH")
	field(EGU, "")	
    info(archive, "VAL")
}

record(longin, "$(P)$(Q)MONITORCOUNTS")
{
    field(DESC, "Displayed Monitor Counts")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(icp,0,0)MONITORCOUNTS")
    field(SCAN, "I/O Intr")
    info(INTEREST, "HIGH")
	field(EGU, "count")
    info(archive, "VAL")
}

record(longin, "$(P)$(Q)MONITORSPECTRUM")
{
    field(DESC, "Displayed Monitor Spectrum Number")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(icp,0,0)MONITORSPECTRUM")
    field(SCAN, "I/O Intr")
    info(INTEREST, "HIGH")
	field(EGU, "")
    info(archive, "VAL")
}

record(longin, "$(P)$(Q)PERIODSEQ")
{
    field(DESC, "Number of Hardware Period Sequences")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(icp,0,0)PERIODSEQ")
    field(SCAN, "I/O Intr")
    info(INTEREST, "HIGH")
	field(EGU, "")
	field(UDFS, "NO_ALARM")
    info(archive, "VAL")
}

record(ai, "$(P)$(Q)BEAMCURRENT")
{
    field(DESC, "DAE Effective Beam Current")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(icp,0,0)BEAMCURRENT")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
    info(INTEREST, "HIGH")
	field(EGU, "uA")
    info(archive, "-5.0 VAL")
}

record(ai, "$(P)$(Q)TOTALUAMPS")
{
    field(DESC, "DAE Raw Microamps")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(icp,0,0)TOTALUAMPS")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
    info(INTEREST, "HIGH")
	field(EGU, "uA hour")
    info(archive, "-5.0 VAL")
}

record(ai, "$(P)$(Q)TOTALUAMPS_PD")
{
    field(DESC, "DAE Raw Period Microamps")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(icp,0,0)TOTALUAMPSPD")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
	field(EGU, "uA hour")
    info(archive, "-5.0 VAL")
}

record(ai, "$(P)$(Q)MEVENTS")
{
    field(DESC, "DAE millions of events")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(icp,0,0)MEVENTS")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
    info(INTEREST, "HIGH")
    info(archive, "-5.0 VAL")
	field(EGU, "Mevent")
}

## historical alias
record(ai, "$(P)$(Q)TOTALDAECOUNTS")
{
    field(DESC, "DAE millions of counts")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(icp,0,0)MEVENTS")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
    info(archive, "-5.0 VAL")
	field(EGU, "Mcount")
}

record(ai, "$(P)$(Q)MONITORTO")
{
    field(DESC, "Display Mon High Integral time")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(icp,0,0)MONITORTO")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
	field(EGU, "us")
	field(UDFS, "NO_ALARM")
    info(archive, "VAL EGU")
}

record(ai, "$(P)$(Q)MONITORFROM")
{
    field(DESC, "Display Mon Low Integral time")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(icp,0,0)MONITORFROM")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
	field(EGU, "us")
	field(UDFS, "NO_ALARM")
    info(archive, "VAL EGU")
}

record(ai, "$(P)$(Q)COUNTRATE")
{
    field(DESC, "DAE Count Rate")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(icp,0,0)COUNTRATE")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
	field(EGU, "")
    info(INTEREST, "HIGH")
    info(archive, "-5.0 VAL")
}

record(ai, "$(P)$(Q)COUNTRATEFRAME")
{
    field(DESC, "DAE Count Rate")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(icp,0,0)COUNTRATEFRAME")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
	field(EGU, "")
    info(INTEREST, "HIGH")
    info(archive, "-5.0 VAL")
}

record(ai, "$(P)$(Q)EVENTMODEFRACTION")
{
    field(DESC, "Event Mode DAE Card Fraction")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(icp,0,0)EVENTMODEFRACTION")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
    info(INTEREST, "HIGH")
	field(EGU, "")
    info(archive, "VAL")
}

record(ai, "$(P)$(Q)EVENTMODEBUFUSED")
{
    field(DESC, "Event Mode Buffer used Fraction")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(icp,0,0)EVENTMODEBUFFERUSED")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
    info(INTEREST, "HIGH")
	field(EGU, "")
    info(archive, "-5.0 VAL")
}

record(ai, "$(P)$(Q)EVENTMODEFILEMB")
{
    field(DESC, "Event Mode File Size")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(icp,0,0)EVENTMODEFILEMB")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
    info(INTEREST, "HIGH")
	field(EGU, "MB")
    info(archive, "-5.0 VAL")
}

record(ai, "$(P)$(Q)EVENTMODEDATARATE")
{
    field(DESC, "Event Mode Data Rate")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(icp,0,0)EVENTMODEDATARATE")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
    info(INTEREST, "HIGH")
	field(EGU, "MB /s")
    info(archive, "-5.0 VAL")
}

record(ai, "$(P)$(Q)GOODUAH")
{
    field(DESC, "DAE Good Microamps")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(icp,0,0)GOODUAH")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
    info(INTEREST, "HIGH")
	field(EGU, "uA hour")
    info(archive, "-5.0 VAL")
}

record(ai, "$(P)$(Q)GOODUAH_PD")
{
    field(DESC, "Period DAE Good Microamps")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(icp,0,0)GOODUAHPD")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
	field(EGU, "uA hour")
    info(archive, "-5.0 VAL")
}

record(bo, "$(P)$(Q)BEGINRUN")
{
    field(DESC, "Begin a Run")
    field(ZNAM, "0")
    field(ONAM, "1")
    #Set the initial alarm state
    field(UDFS, "NO_ALARM")
    field(FLNK, "$(BEGINRUNA=$(P)$(Q)_BEGINRUN:FAN).PROC")
}

## etc PRE_BEGIN_1 must include CA attribute is a wait is needed
record(sseq, "$(P)$(Q)_BEGINRUN:FAN")
{
    field(LNK1, "$(P)CS:RC:SYNC:SP.PROC")
    field(LNK2, "$(PRE_BEGIN_1=)")
    field(WAIT2, "Wait")
    field(LNK3, "$(PRE_BEGIN_2=)")
    field(WAIT3, "Wait")
    field(LNK4, "$(PRE_BEGIN_3=)")
    field(WAIT4, "Wait")
    field(LNK5, "$(PRE_BEGIN_4=)")
    field(WAIT5, "Wait")
    field(LNK6, "$(P)$(Q)BEGINRUN_.PROC CA")
    field(WAIT6, "Wait")
    field(DO7, "1")
    field(LNK7, "$(POST_BEGIN_1=)")
    field(WAIT7, "Wait")
    field(DO8, "1")
    field(LNK8, "$(POST_BEGIN_2=)")
    field(WAIT8, "Wait")
    field(DO9, "1")
    field(LNK9, "$(POST_BEGIN_3=)")
    field(WAIT9, "Wait")
    field(DOA, "1")
    field(LNKA, "$(POST_BEGIN_4=)")
    field(WAITA, "Wait")
}

record(bo, "$(P)$(Q)BEGINRUN_")
{
    field(DESC, "Begin a Run")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(icp,0,0)BEGINRUN")
    #Set the initial alarm state
    field(UDFS, "NO_ALARM")
    field(ZNAM, "0")
    field(ONAM, "1")
    field(VAL, 1)
    field(FLNK, "$(P)$(Q)_RESTART_ARCHIVER.PROC CA")
}

## value sent controls begin options (such as DELAYED or PAUSED)
record(longout, "$(P)$(Q)BEGINRUNEX")
{
    field(DESC, "Begin a Run (with options)")
    #Set the initial alarm state
    field(UDFS, "NO_ALARM")
    field(FLNK, "$(P)$(Q)_BEGINRUNEX:FAN.PROC")
}

## PRE_BEGIN_1 etc must include CA attribute if a wait is needed
record(sseq, "$(P)$(Q)_BEGINRUNEX:FAN")
{
    field(LNK1, "$(P)CS:RC:SYNC:SP.PROC")
    field(LNK2, "$(PRE_BEGIN_1=)")
    field(WAIT2, "Wait")
    field(LNK3, "$(PRE_BEGIN_2=)")
    field(WAIT3, "Wait")
    field(LNK4, "$(PRE_BEGIN_3=)")
    field(WAIT4, "Wait")
    field(LNK5, "$(PRE_BEGIN_4=)")
    field(WAIT5, "Wait")
    field(LNK6, "$(P)$(Q)_BEGINRUNEX1.PROC CA")
    field(WAIT6, "Wait")
    field(DO7, "1")
    field(LNK7, "$(POST_BEGIN_1=)")
    field(WAIT7, "Wait")
    field(DO8, "1")
    field(LNK8, "$(POST_BEGIN_2=)")
    field(WAIT8, "Wait")
    field(DO9, "1")
    field(LNK9, "$(POST_BEGIN_3=)")
    field(WAIT9, "Wait")
    field(DOA, "1")
    field(LNKA, "$(POST_BEGIN_4=)")
    field(WAITA, "Wait")
}

record(longout, "$(P)$(Q)_BEGINRUNEX1")
{
    field(DOL, "$(P)$(Q)BEGINRUNEX")
    field(OMSL, "closed_loop")
    field(OUT,  "$(P)$(Q)BEGINRUNEX_ PP")
}

record(longout, "$(P)$(Q)BEGINRUNEX_")
{
    field(DESC, "Begin a Run (with options)")
    field(DTYP, "asynInt32")
    #Set the initial alarm state
    field(UDFS, "NO_ALARM")
    field(OUT,  "@asyn(icp,0,0)BEGINRUNEX")
    field(FLNK, "$(P)$(Q)_RESTART_ARCHIVER.PROC CA")
}

record(bo, "$(P)$(Q)ENDRUN")
{
    field(DESC, "End a Run")
    field(ZNAM, "0")
    field(ONAM, "1")
    #Set the initial alarm state
    field(UDFS, "NO_ALARM")
    field(FLNK, "$(ENDRUNA=$(P)$(Q)_ENDRUN:FAN).PROC")
}

## PRE_END_1 etc must include CA attribute is a wait is needed
record(sseq, "$(P)$(Q)_ENDRUN:FAN")
{
    field(LNK1, "$(PRE_END_1=)")
    field(WAIT1, "Wait")
    field(LNK2, "$(PRE_END_2=)")
    field(WAIT2, "Wait")
    field(LNK3, "$(PRE_END_3=)")
    field(WAIT3, "Wait")
    field(LNK4, "$(PRE_END_4=)")
    field(WAIT4, "Wait")
    field(LNK5, "$(P)$(Q)ENDRUN_.PROC CA")
    field(WAIT5, "Wait")
    field(DO6, "1")
    field(LNK6, "$(POST_END_1=)")
    field(WAIT6, "Wait")
    field(DO7, "1")
    field(LNK7, "$(POST_END_2=)")
    field(WAIT7, "Wait")
    field(DO8, "1")
    field(LNK8, "$(POST_END_3=)")
    field(WAIT8, "Wait")
    field(DO9, "1")
    field(LNK9, "$(POST_END_4=)")
    field(WAIT9, "Wait")
}

record(seq, "$(P)$(Q)ENDRUN_")
{
    field(SELM, "All")
    field(DOL1, "1")
    field(LNK1, "$(P)$(Q)_RESTART_ARCHIVER.PROC CA")
    # give archive time to restart
    field(DOL2, "1")
    field(DLY2, "1")
    field(LNK2, "$(P)$(Q)_ENDRUN2 PP")
    #Set the initial alarm state
    field(UDFS, "NO_ALARM")
}

record(bo, "$(P)$(Q)_ENDRUN2")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(icp,0,0)ENDRUN")
    field(ZNAM, "0")
    field(ONAM, "1")
    #Set the initial alarm state
    field(UDFS, "NO_ALARM")
}

record(bo, "$(P)$(Q)RECOVERRUN")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(icp,0,0)RECOVERRUN")
    field(ZNAM, "0")
    field(ONAM, "1")
    #Set the initial alarm state
    field(UDFS, "NO_ALARM")
}

record(bo, "$(P)$(Q)SAVERUN")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(icp,0,0)SAVERUN")
    field(ZNAM, "0")
    field(ONAM, "1")
    #Set the initial alarm state
    field(UDFS, "NO_ALARM")
}

record(bo, "$(P)$(Q)UPDATERUN")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(icp,0,0)UPDATERUN")
    field(ZNAM, "0")
    field(ONAM, "1")
    #Set the initial alarm state
    field(UDFS, "NO_ALARM")
}

record(bo, "$(P)$(Q)STORERUN")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(icp,0,0)STORERUN")
    field(ZNAM, "0")
    field(ONAM, "1")
    #Set the initial alarm state
    field(UDFS, "NO_ALARM")
}

record(waveform, "$(P)$(Q)SNAPSHOTCRPT")
{
    field(NELM, "1024")
    field(FTVL, "CHAR")
    field(DTYP, "asynOctetWrite")
    field(INP, "@asyn(icp,0,0)SNAPSHOTCRPT")
    #Set the initial alarm state
    field(UDFS, "NO_ALARM")
}

record(bo, "$(P)$(Q)SEWAIT")
{
    field(DTYP, "asynInt32")
    field(ZNAM, "0")
    field(ONAM, "1")
    field(OUT,  "@asyn(icp,0,0)SEWAIT")
}

## show number of seconds in WAITING state
record(ai, "$(P)$(Q)WAITING:TIME")
{
    field(VAL, "0")
    field(DESC, "Time in WAITING state")
	field(EGU, "s")
	field(PREC, "1")
}

## calculate number of seconds in WAITING state
record(calcout, "$(P)$(Q)WAITING:TIME:_CALC")
{
    field(INPA, "$(P)$(Q)RUNSTATE NPP")
    field(INPB, "$(P)$(Q)WAITING:TIME NPP")
	field(CALC, "A = 4 ? B + 1 : 0")
	field(OOPT, "On Change")
    field(OUT, "$(P)$(Q)WAITING:TIME PP")
    field(SCAN, "1 second")
}

## 2 for RUNNING and 4 for WAITING are used in a runcontrol check, so be careful about changing numbers
record(mbbi, "$(P)$(Q)RUNSTATE")
{
    field(DESC, "Run State (Integer/Enum)")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(icp,0,0)RUNSTATUS")
    field(SCAN, "I/O Intr")
    field(ZRVL, 0)
    field(ZRST, "PROCESSING")
    field(ONVL, 1)
    field(ONST, "SETUP")
    field(TWVL, 2)
    field(TWST, "RUNNING")
    field(THVL, 3)
    field(THST, "PAUSED")
    field(FRVL, 4)
    field(FRST, "WAITING")
    field(FVVL, 5)
    field(FVST, "VETOING")
    field(SXVL, 6)
    field(SXST, "ENDING")
    field(SVVL, 7)
    field(SVST, "SAVING")
    field(EIVL, 8)
    field(EIST, "RESUMING")
    field(NIVL, 9)
    field(NIST, "PAUSING")
    field(TEVL, 10)
    field(TEST, "BEGINNING")
    field(ELVL, 11)
    field(ELST, "ABORTING")
    field(TVVL, 12)
    field(TVST, "UPDATING")
    field(TTVL, 13)
    field(TTST, "STORING")
    field(FTVL, 14)
    field(FTST, "CHANGING")
    info(INTEREST, "HIGH")
    info(archive, "VAL")
}

record(stringin, "$(P)$(Q)RUNSTATE_STR")
{
    field(DESC, "Run State (String)")
    field(INP, "$(P)$(Q)RUNSTATE CP")
    info(INTEREST, "HIGH")
    info(archive, "VAL")
}

record(bi, "$(P)$(Q)STATETRANS")
{
    field(DESC, "In state transition")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(icp,0,0)STATETRANS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(SCAN, "I/O Intr")
	info(archive, "VAL")
}

# in CHANGING run state, workaround
record(bi, "$(P)$(Q)STATE:CHANGING")
{
    field(DESC, "In changing state")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(icp,0,0)INCHANGINGSTATE")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(SCAN, "I/O Intr")
	info(archive, "VAL")
}

# number of seconds in transition state
record(ai, "$(P)$(Q)STATETRANS:TIME")
{
    field(VAL, "0")
    field(DESC, "Time in state transition")
	field(EGU, "s")
	field(PREC, "1")
}

# calculate number of seconds in transition state
record(calcout, "$(P)$(Q)STATETRANS:TIME:_CALC")
{
    field(INPA, "$(P)$(Q)STATETRANS NPP")
    field(INPB, "$(P)$(Q)STATETRANS:TIME NPP")
	field(CALC, "A != 0 ? B + 1 : 0")
	field(OOPT, "On Change")
    field(OUT, "$(P)$(Q)STATETRANS:TIME PP")
    field(SCAN, "1 second")
}

record(longin, "$(P)$(Q)PERIOD")
{
    field(DESC, "DAE Period Number")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(icp,0,0)PERIOD")
    field(SCAN, "I/O Intr")
    field(UDFS, "NO_ALARM")
    info(INTEREST, "HIGH")
	info(archive, "VAL")
	field(EGU, "")
}

record(longout, "$(P)$(Q)PERIOD:SP")
{
    field(DESC, "Change DAE Period Number")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(icp,0,0)PERIOD")
    field(UDFS, "NO_ALARM")
}

alias("$(P)$(Q)PERIOD", "$(P)$(Q)PERIOD:SP:RBV")

# fast change period, does pause/chane/resume in one
# operation. pass a negative period number to skip
# even the pause/resume
record(longout, "$(P)$(Q)FCPERIOD:SP")
{
    field(DESC, "Change DAE Period Number quickly")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(icp,0,0)FASTPERIODCHANGE")
    field(UDFS, "NO_ALARM")
}

record(longin, "$(P)$(Q)NUMPERIODS")
{
    field(DESC, "Number of DAE periods")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(icp,0,0)NUMPERIODS")
    field(SCAN, "I/O Intr")
    field(UDFS, "NO_ALARM")
    info(INTEREST, "HIGH")
	field(EGU, "")
	info(archive, "VAL")
}

record(longout, "$(P)$(Q)NUMPERIODS:SP")
{
    field(DESC, "Change Number of DAE periods")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(icp,0,0)NUMPERIODS")
    field(UDFS, "NO_ALARM")
}

alias("$(P)$(Q)NUMPERIODS", "$(P)$(Q)NUMPERIODS:SP:RBV")

record(longin, "$(P)$(Q)TOTALCOUNTS")
{
    field(DESC, "Total counts")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(icp,0,0)TOTALCOUNTS")
    field(SCAN, "I/O Intr")
    info(INTEREST, "HIGH")
	field(EGU, "count")
    info(archive, "-5.0 VAL")
}

# historical alias
record(longin, "$(P)$(Q)EVENTS")
{
    field(DESC, "Total counts")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(icp,0,0)TOTALCOUNTS")
    field(SCAN, "I/O Intr")
	field(EGU, "event")
    info(archive, "-5.0 VAL")
}

record(waveform, "$(P)$(Q)DAESETTINGS")
{
    field(NELM, "10000")
    field(FTVL, "CHAR")
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(icp,0,0)DAESETTINGS")
    field(SCAN, "I/O Intr")
}

record(waveform, "$(P)$(Q)DAESETTINGS:SP")
{
    field(NELM, "10000")
    field(FTVL, "CHAR")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(icp,0,0)DAESETTINGS")
}

record(waveform, "$(P)$(Q)TCBSETTINGS")
{
    field(NELM, "10000")
    field(FTVL, "UCHAR")
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(icp,0,0)TCBSETTINGS")
    field(SCAN, "I/O Intr")
}

record(waveform, "$(P)$(Q)TCBSETTINGS:SP")
{
    field(NELM, "10000")
    field(FTVL, "UCHAR")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(icp,0,0)TCBSETTINGS")
}

record(waveform, "$(P)$(Q)HARDWAREPERIODS")
{
    field(NELM, "10000")
    field(FTVL, "CHAR")
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(icp,0,0)HARDWAREPERIODSSETTINGS")
    field(SCAN, "I/O Intr")
}

record(waveform, "$(P)$(Q)HARDWAREPERIODS:SP")
{
    field(NELM, "10000")
    field(FTVL, "CHAR")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(icp,0,0)HARDWAREPERIODSSETTINGS")
}

record(waveform, "$(P)$(Q)UPDATESETTINGS")
{
    field(NELM, "10000")
    field(FTVL, "CHAR")
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(icp,0,0)UPDATESETTINGS")
    field(SCAN, "I/O Intr")
}

record(waveform, "$(P)$(Q)UPDATESETTINGS:SP")
{
    field(NELM, "10000")
    field(FTVL, "CHAR")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(icp,0,0)UPDATESETTINGS")
}

record(waveform, "$(P)$(Q)VETOSTATUS")
{
    field(NELM, "3000")
    field(FTVL, "CHAR")
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(icp,0,0)VETOSTATUS")
    field(SCAN, "I/O Intr")
}

record(ai, "$(P)$(Q)VETOPC")
{
    field(DESC, "Vetoing %")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(icp,0,0)VETOPC")
    field(SCAN, "I/O Intr")
	field(EGU, "%")
# useful to log, but need a good deadband value or will get too much data
	field(ADEL, 5.0)
	info(archive, "-5.0 VAL")
}

record(stringout, "$(P)$(Q)VETO:ENABLE:SP")
{
    field(DESC, "Enable veto")
    field(DTYP, "asynOctetWrite")
    field(OUT,  "@asyn(icp,0,0)VETO_ENABLE")
    info(archive, "VAL")
}

record(stringout, "$(P)$(Q)VETO:DISABLE:SP")
{
    field(DESC, "Disable veto")
    field(DTYP, "asynOctetWrite")
    field(OUT,  "@asyn(icp,0,0)VETO_DISABLE")
    info(archive, "VAL")
}

record(waveform, "$(P)$(Q)ALLMSGS")
{
    field(NELM, "4096")
    field(FTVL, "CHAR")
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(icp,0,0)ALLMSGS")
    field(SCAN, "I/O Intr")
}

record(waveform, "$(P)$(Q)ERRMSGS")
{
    field(NELM, "4096")
    field(FTVL, "CHAR")
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(icp,0,0)ERRMSGS")
    field(SCAN, "I/O Intr")
}

record(waveform, "$(P)$(Q)WIRING_FILE")
{
   field(DESC, "Wiring table filename")
   field(DTYP, "asynOctetRead")
   field(INP, "@asyn(icp,0,0)WIRINGFILE")
   field(SCAN, "I/O Intr")
   field(FTVL, "CHAR")
   field(NELM, 256)
}

record(waveform, "$(P)$(Q)DETECTOR_FILE")
{
   field(DESC, "Detector table filename")
   field(DTYP, "asynOctetRead")
   field(INP, "@asyn(icp,0,0)DETFILE")
   field(SCAN, "I/O Intr")
   field(FTVL, "CHAR")
   field(NELM, 256)
}

record(waveform, "$(P)$(Q)SPECTRA_FILE")
{
   field(DESC, "Spectra table filename")
   field(DTYP, "asynOctetRead")
   field(INP, "@asyn(icp,0,0)SPECFILE")
   field(SCAN, "I/O Intr")
   field(FTVL, "CHAR")
   field(NELM, 256)
}

record(waveform, "$(P)$(Q)TCB_FILE")
{
   field(DESC, "TCB filename")
   field(DTYP, "asynOctetRead")
   field(INP, "@asyn(icp,0,0)TCBFILE")
   field(SCAN, "I/O Intr")
   field(FTVL, "CHAR")
   field(NELM, 256)
}

record(waveform, "$(P)$(Q)PERIOD_FILE")
{
   field(DESC, "Periods filename")
   field(DTYP, "asynOctetRead")
   field(INP, "@asyn(icp,0,0)PERIODSFILE")
   field(SCAN, "I/O Intr")
   field(FTVL, "CHAR")
   field(NELM, 256)
}

##############################################################################################
## FileList for wiring tables
##############################################################################################

record(waveform, "$(P)$(Q)WIRING_DIR:SP")
{
   field(DESC, "Set directory of wiring tables")
   field(DTYP, "asynOctetWrite")
   field(INP, "@asyn($(WIRINGLIST),0,1)DIRBASE")
   field(FTVL, "CHAR")
   field(NELM, 256)
}

record(waveform, "$(P)$(Q)WIRING_DIR")
{
   field(DESC, "Get directory of wiring tables")
   field(DTYP, "asynOctetRead")
   field(INP, "@asyn($(WIRINGLIST),0,1)DIRBASE")
   field(SCAN, "I/O Intr")
   field(PINI, "YES")
   field(FTVL, "CHAR")
   field(NELM, 256)
}

record(waveform, "$(P)$(Q)WIRINGTABLES")
{
	field(DESC, "Compressed JSON list of wiring tables")
	field(FTVL, "CHAR")
	field(DTYP, "asynOctetRead")
    field(INP, "@asyn($(WIRINGLIST),0,1)JARR")	
	field(NELM, 16384)
	field(SCAN, "I/O Intr")
    field(PINI, "YES")
}

record(waveform, "$(P)$(Q)WIRING_PATTERN:SP")
{
   field(DESC, "Set regex search of wiring tables")  
   field(DTYP, "asynOctetWrite")
   field(INP, "@asyn($(WIRINGLIST),0,1)SEARCH")
   field(FTVL, "CHAR")
   field(NELM, 256)
}
record(waveform, "$(P)$(Q)WIRING_PATTERN")
{
   field(DESC, "Get regex search of wiring tables")
   field(DTYP, "asynOctetRead")
   field(INP, "@asyn($(WIRINGLIST),0,1)SEARCH")
   field(SCAN, "I/O Intr")
   field(PINI, "YES")
   field(FTVL, "CHAR")
   field(NELM, 256)
}

##############################################################################################
## FileList for detector tables
##############################################################################################

record(waveform, "$(P)$(Q)DETECTOR_DIR:SP")
{
   field(DESC, "Set directory of detector tables")
   field(DTYP, "asynOctetWrite")
   field(INP, "@asyn($(DETECTORLIST),0,1)DIRBASE")
   field(FTVL, "CHAR")
   field(NELM, 256)
}

record(waveform, "$(P)$(Q)DETECTOR_DIR")
{
   field(DESC, "Get directory of detector tables")
   field(DTYP, "asynOctetRead")
   field(INP, "@asyn($(DETECTORLIST),0,1)DIRBASE")
   field(SCAN, "I/O Intr")
   field(PINI, "YES")
   field(FTVL, "CHAR")
   field(NELM, 256)
}

record(waveform, "$(P)$(Q)DETECTORTABLES")
{
	field(DESC, "Compressed JSON list of detector tables")
	field(FTVL, "CHAR")
	field(DTYP, "asynOctetRead")
    field(INP, "@asyn($(DETECTORLIST),0,1)JARR")	
	field(NELM, 16384)
	field(SCAN, "I/O Intr")
    field(PINI, "YES")
}

record(waveform, "$(P)$(Q)DETECTOR_PATTERN:SP")
{
   field(DESC, "Set regex search of detector tables")  
   field(DTYP, "asynOctetWrite")
   field(INP, "@asyn($(DETECTORLIST),0,1)SEARCH")
   field(FTVL, "CHAR")
   field(NELM, 256)
}
record(waveform, "$(P)$(Q)DETECTOR_PATTERN")
{
   field(DESC, "Get regex search of detector tables")
   field(DTYP, "asynOctetRead")
   field(INP, "@asyn($(DETECTORLIST),0,1)SEARCH")
   field(SCAN, "I/O Intr")
   field(PINI, "YES")
   field(FTVL, "CHAR")
   field(NELM, 256)
}

##############################################################################################
## FileList parameters for spectra tables
##############################################################################################

record(waveform, "$(P)$(Q)SPECTRA_DIR:SP")
{
   field(DESC, "Set directory of spectra tables")
   field(DTYP, "asynOctetWrite")
   field(INP, "@asyn($(SPECTRALIST),0,1)DIRBASE")
   field(FTVL, "CHAR")
   field(NELM, 256)
}

record(waveform, "$(P)$(Q)SPECTRA_DIR")
{
   field(DESC, "Get directory of spectra tables")
   field(DTYP, "asynOctetRead")
   field(INP, "@asyn($(SPECTRALIST),0,1)DIRBASE")
   field(SCAN, "I/O Intr")
   field(PINI, "YES")
   field(FTVL, "CHAR")
   field(NELM, 256)
}

record(waveform, "$(P)$(Q)SPECTRATABLES")
{
	field(DESC, "Compressed JSON list of spectra tables")
	field(FTVL, "CHAR")
	field(DTYP, "asynOctetRead")
    field(INP, "@asyn($(SPECTRALIST),0,1)JARR")	
	field(NELM, 16384)
	field(SCAN, "I/O Intr")
    field(PINI, "YES")
}

record(waveform, "$(P)$(Q)SPECTRA_PATTERN:SP")
{
   field(DESC, "Set regex search of spectra tables")  
   field(DTYP, "asynOctetWrite")
   field(INP, "@asyn($(SPECTRALIST),0,1)SEARCH")
   field(FTVL, "CHAR")
   field(NELM, 256)
}
record(waveform, "$(P)$(Q)SPECTRA_PATTERN")
{
   field(DESC, "Get regex search of spectra tables")
   field(DTYP, "asynOctetRead")
   field(INP, "@asyn($(SPECTRALIST),0,1)SEARCH")
   field(SCAN, "I/O Intr")
   field(PINI, "YES")
   field(FTVL, "CHAR")
   field(NELM, 256)
}

##############################################################################################
## FileList for TCB files
##############################################################################################

record(waveform, "$(P)$(Q)TCB_DIR:SP")
{
   field(DESC, "Set directory of TCB files")
   field(DTYP, "asynOctetWrite")
   field(INP, "@asyn($(TCBLIST),0,1)DIRBASE")
   field(FTVL, "CHAR")
   field(NELM, 256)
}

record(waveform, "$(P)$(Q)TCB_DIR")
{
   field(DESC, "Get directory of TCB Files")
   field(DTYP, "asynOctetRead")
   field(INP, "@asyn($(TCBLIST),0,1)DIRBASE")
   field(SCAN, "I/O Intr")
   field(PINI, "YES")
   field(FTVL, "CHAR")
   field(NELM, 256)
}

record(waveform, "$(P)$(Q)TCBFILES")
{
	field(DESC, "Compressed JSON list of TCB Files")
	field(FTVL, "CHAR")
	field(DTYP, "asynOctetRead")
    field(INP, "@asyn($(TCBLIST),0,1)JARR")	
	field(NELM, 16384)
	field(SCAN, "I/O Intr")
    field(PINI, "YES")
}

record(waveform, "$(P)$(Q)TCB_PATTERN:SP")
{
   field(DESC, "Set regex search of TCB files")  
   field(DTYP, "asynOctetWrite")
   field(INP, "@asyn($(TCBLIST),0,1)SEARCH")
   field(FTVL, "CHAR")
   field(NELM, 256)
}
record(waveform, "$(P)$(Q)TCB_PATTERN")
{
   field(DESC, "Get regex search of TCB files")
   field(DTYP, "asynOctetRead")
   field(INP, "@asyn($(TCBLIST),0,1)SEARCH")
   field(SCAN, "I/O Intr")
   field(PINI, "YES")
   field(FTVL, "CHAR")
   field(NELM, 256)
}

##############################################################################################
## FileList parameters for period files
##############################################################################################

record(waveform, "$(P)$(Q)PERIOD_DIR:SP")
{
   field(DESC, "Set directory of period files")
   field(DTYP, "asynOctetWrite")
   field(INP, "@asyn($(PERIODLIST),0,1)DIRBASE")
   field(FTVL, "CHAR")
   field(NELM, 256)
}

record(waveform, "$(P)$(Q)PERIOD_DIR")
{
   field(DESC, "Get directory of period files")
   field(DTYP, "asynOctetRead")
   field(INP, "@asyn($(PERIODLIST),0,1)DIRBASE")
   field(SCAN, "I/O Intr")
   field(PINI, "YES")
   field(FTVL, "CHAR")
   field(NELM, 256)
}

record(waveform, "$(P)$(Q)PERIODFILES")
{
	field(DESC, "Compressed JSON list of period files")
	field(FTVL, "CHAR")
	field(DTYP, "asynOctetRead")
    field(INP, "@asyn($(PERIODLIST),0,1)JARR")	
	field(NELM, 16384)
	field(SCAN, "I/O Intr")
    field(PINI, "YES")
}

record(waveform, "$(P)$(Q)PERIOD_PATTERN:SP")
{
   field(DESC, "Set regex search of period files")  
   field(DTYP, "asynOctetWrite")
   field(INP, "@asyn($(PERIODLIST),0,1)SEARCH")
   field(FTVL, "CHAR")
   field(NELM, 256)
}
record(waveform, "$(P)$(Q)PERIOD_PATTERN")
{
   field(DESC, "Get regex search of period files")
   field(DTYP, "asynOctetRead")
   field(INP, "@asyn($(PERIODLIST),0,1)SEARCH")
   field(SCAN, "I/O Intr")
   field(PINI, "YES")
   field(FTVL, "CHAR")
   field(NELM, 256)
}

##############################################################################################
## records for restarting archive engine on a begin and end
##############################################################################################

## force processing of _RESTART_ARCHIVER via forward link to restart archiver
## don't restart more than once a second which is about what archiver can manage
record(seq, "$(P)$(Q)_RESTART_ARCHIVER")
{
    field(SELM, "All")
    field(DOL1, "1")
    field(LNK1, "$(P)$(Q)_RESTART_ARCHIVER1.PROC PP")
    field(DOL2, "1")
    field(DLY2, "1.0")
    field(LNK2, "$(P)$(Q)_RESTART_ARCHIVER_CNT.PROC PP")
    field(SCAN, "Passive")
}

record(calc, "$(P)$(Q)_RESTART_ARCHIVER_CNT")
{
    field(CALC, "A:=A+1;A")
}

## ask block archiver to restart
record(stringin, "$(P)$(Q)_RESTART_ARCHIVER1")
{
    field(DTYP, "asynOctetRead")
    field(INP, "@asyn(arch1,0,0)DATA0")
    field(SCAN, "Passive")
}

## URL for block archiver restart request
record(stringout, "$(P)$(Q)_RESTART_ARCHIVER_URL")
{
    field(DTYP, "asynOctetWrite")
    field(OUT, "@asyn(arch1,0,0)URL0")
    field(PINI, "YES")
    field(VAL, "http://localhost:4813/restart")
}

## check archiver
## we take several periodic readings as we may try to read archiver when
## it is reloading and get an invalid answer


## URL of block archiver status page
record(stringout, "$(P)$(Q)_CHECK_ARCHIVER_URL")
{
    field(DTYP, "asynOctetWrite")
    field(OUT, "@asyn(arch2,0,0)URL0")
    field(PINI, "YES")
    field(VAL, "http://localhost:4813/main")
}

## XPath expression to check status web page for whether archiver is RUNNING
record(stringout, "$(P)$(Q)_CHECK_ARCHIVER_XPATH")
{
    field(DTYP, "asynOctetWrite")
    field(OUT, "@asyn(arch2,0,0)XPATH0")
    field(PINI, "YES")
    field(VAL, "count(//*[text()='RUNNING'])")
}

## check block archiver status - contains 1 if RUNNING, 0 if not
## set VAL to 1 on init so that on startup it does not trigger
## a nagios check warning that it is STOPPED
record(bi, "$(P)$(Q)_CHECK_ARCHIVER")
{
    field(DTYP, "asynInt32")
    field(ZNAM, "STOPPED")
    field(ONAM, "RUNNING")
    field(INP, "@asyn(arch2,0,0)IDATA0")
    field(SCAN, "10 second")
    field(VAL, "1")
    field(UDFS, "NO_ALARM")
    field(FLNK, "$(P)$(Q)_CHECK_ARCHIVER_SAMP.PROC")
}

## keep last NSAM status reading in a circular buffer
record(compress, "$(P)$(Q)_CHECK_ARCHIVER_SAMP")
{
    field(INP, "$(P)$(Q)_CHECK_ARCHIVER NPP")
    field(ALG, "Circular Buffer")
    field(NSAM, "5")
    field(FLNK, "$(P)$(Q)_CHECK_ARCHIVER_COMP.PROC")
}

## take highest value of above reading
## here N must be same as NSAM above
record(compress, "$(P)$(Q)_CHECK_ARCHIVER_COMP")
{
    field(INP, "$(P)$(Q)_CHECK_ARCHIVER_SAMP NPP")
    field(ALG, "N to 1 High Value")
    field(N, "5")
    field(FLNK, "$(P)$(Q)_CHECK_ARCHIVER_CALC.PROC")
}

# signal a hard restart of the block archiver via procServ
# if archiver has not been running for a while
record(calcout, "$(P)$(Q)_CHECK_ARCHIVER_CALC")
{
    field(INPA, "$(P)$(Q)_CHECK_ARCHIVER_COMP NPP")
    field(INPB, "1")
    field(CALC, "A=B")
    field(OOPT, "When Zero")
    field(OUT, "$(P)$(Q)_FR_ARCHIVER_MSG.PROC PP")
}

record(stringout, "$(P)$(Q)_FR_ARCHIVER_MSG")
{
    field(DTYP, "stdio")
    field(OUT, "@stdout")
    field(VAL, "*** Restarting ARBLOCK ***")
    field(UDFS, "NO_ALARM")
    field(FLNK, "$(P)$(Q)_FR_ARCHIVER_CNT.PROC")
}

## count of forced restarts of block archiver
record(calc, "$(P)$(Q)_FR_ARCHIVER_CNT")
{
    field(CALC, "A:=A+1;A")
    field(ASG, "READONLY")
    field(UDFS, "NO_ALARM")
    field(FLNK, "$(P)$(Q)_FR_ARCHIVER_PS.PROC")
}

## restart block archiver using procServ via procServControl
record(longout, "$(P)$(Q)_FR_ARCHIVER_PS")
{
    field(OUT, "$(P)CS:PS:ARBLOCK:RESTART PP")
    field(VAL, 1)
}

## has simulation mode been enabled in ISISICP
record(bi, "$(P)$(Q)SIM_MODE")
{
    field(DESC, "Is DAE in simulation mode")
    field(DTYP, "asynInt32")
	field(ZNAM, "No")
	field(ONAM, "Yes")
    field(INP, "@asyn(icp,0,0)SIM_MODE")
	field(SCAN, "I/O Intr")
	info(INTEREST, "HIGH")
	field(UDFS, "NO_ALARM")
    info(archive, "VAL")
}

## We use NPP on OUT as the PARS:BL:CURR_CONFIG is already on a periodic
## scan loop to send to isisicp
record(lso, "$(P)$(Q)CURR_CONFIG")
{
    field(DOL, "$(P)CS:BLOCKSERVER:CURR_CONFIG_NAME")
	field(OMSL, "closed_loop")
	field(OUT, "$(P)PARS:BL:CURR_CONFIG NPP")
	field(SCAN, "10 second")
	field(SIZV, "256")
}

record(calcout, "$(P)$(Q)_HRPDINT")
{
    field(INPA, "$(P)$(Q)VETO:EXT3:PC CP")
    field(INPB, "$(P)$(Q)RUNSTATE CP")
    field(CALC, "(B=5||B=2)?(A > 50 ? 0 : 1) : 2")
    field(OUT, "$(P)$(Q)HRPDINT PP")
    field(OOPT, "On Change")
}

record(mbbi, "$(P)$(Q)HRPDINT")
{
    field(ZRVL, 0)
    field(ONVL, 1)
    field(TWVL, 2)
    field(ZRST, "CLOSED")
    field(ONST, "OPEN")
    field(TWST, "UNKNOWN")
    field(ZRSV, "MINOR")
    field(TWSV, "MINOR")
}

record(mbbi, "$(P)$(Q)DAETYPE")
{
    field(DESC, "DAE Type")
    field(ZRVL, 0)
    field(ONVL, 1)
    field(TWVL, 2)
    field(THVL, 3)
    field(FRVL, 4)
    field(ZRST, "Unknown")
    field(ONST, "NeutronDAE2")
    field(TWST, "MuonDAE2")
    field(THST, "NeutronDAE3")
    field(FRST, "MuonDAE3")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(icp,0,0)DAETYPE")
    field(SCAN, "I/O Intr")
}

record(bi, "$(P)$(Q)ISMUON")
{
    field(DESC, "Is Muon DAE?")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(icp,0,0)ISMUONDAE")
    field(SCAN, "I/O Intr")
    field(ZNAM, "No")
    field(ONAM, "Yes")
}

## card_id, card_address, word_size(0=16bit, 1=32 bit)
record(waveform, "$(P)$(Q)VMEREADVALUE:PROPS")
{
    field(DESC, "VMEReadValue props")
    field(NELM, "3")
    field(FTVL, "LONG")
    field(DTYP, "asynInt32ArrayOut")
    field(INP,  "@asyn(icp,0,0)VMEREADVALUEPROPS")
    field(FLNK,  "$(P)$(Q)VMEREADVALUE:DATA")
}

record(longin, "$(P)$(Q)VMEREADVALUE:DATA")
{
    field(DESC, "VMEReadValue data")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(icp,0,0)VMEREADVALUEDATA")
}

## card_id, card_address, word_size (0=16bit, 1=32 bit), mode (0=set,1=and,2=or,3=xor), value
record(waveform, "$(P)$(Q)VMEWRITEVALUE")
{
    field(DESC, "VMEWriteValue")
    field(NELM, "5")
    field(FTVL, "ULONG")
    field(DTYP, "asynInt32ArrayOut")
    field(INP,  "@asyn(icp,0,0)VMEWRITEVALUE")
}

## card_id, card_address, num_values
record(waveform, "$(P)$(Q)VMEREADARRAY:PROPS")
{
    field(DESC, "VMEReadArray props")
    field(NELM, "3")
    field(FTVL, "LONG")
    field(DTYP, "asynInt32ArrayOut")
    field(INP,  "@asyn(icp,0,0)VMEREADARRAYPROPS")
    field(FLNK,  "$(P)$(Q)VMEREADARRAY:DATA")
}

## vme read array does TransferBlock | TransferLittleEndian
## vme read value is TransferIORegisterSpace
## check NORD for how many read
record(waveform, "$(P)$(Q)VMEREADARRAY:DATA")
{
    field(DESC, "VMEReadArray data")
    field(DTYP, "asynInt32ArrayIn")
    field(INP,  "@asyn(icp,0,0)VMEREADARRAYDATA")
    field(NELM, "1024")
    field(FTVL, "ULONG")
}

## card_id, card_address, num_values, value1, value2, ...
record(waveform, "$(P)$(Q)VMEWRITEARRAY")
{
    field(DESC, "VMEWriteArray")
    field(NELM, "1027")
    field(FTVL, "ULONG")
    field(DTYP, "asynInt32ArrayOut")
    field(INP,  "@asyn(icp,0,0)VMEWRITEARRAY")
}

## card_id, card_address, num_values, trans_type
## trans_type is ored collection of ISISVME::TransferProp from isisicp
##   TransferNoOptions = 0x0, TransferBlock = 0x1, TransferLittleEndian = 0x2, 
##   TransferIORegisterSpace = 0x4, TransferLUTSpace = 0x8, TransferRunMemorySpace = 0x10, 
##   TransferAbsoluteAddress = 0x20
##   Each DAE3 card is treated as a DAE2 crate, each DAE3 module is like a DAE2 card.
##   The three modules share a registers IO space, some registers are present in all 3 modules at shifted addresses, 
##   some are only present once on DAU0. Specifying TransferAbsoluteAddress negates any module specific shifts. 
##   being applied to the io register read. 
##   TransferLittleEndian is only approariate for DAE2 detector card memory reads as is TransferBlock
record(waveform, "$(P)$(Q)QXREADARRAY:PROPS")
{
    field(DESC, "QXReadArray props")
    field(NELM, "4")
    field(FTVL, "LONG")
    field(DTYP, "asynInt32ArrayOut")
    field(INP,  "@asyn(icp,0,0)QXREADARRAYPROPS")
    field(FLNK,  "$(P)$(Q)QXREADARRAY:DATA")
}

## check NORD for how many read
record(waveform, "$(P)$(Q)QXREADARRAY:DATA")
{
    field(DESC, "QXReadArray data")
    field(DTYP, "asynInt32ArrayIn")
    field(INP,  "@asyn(icp,0,0)QXREADARRAYDATA")
    field(NELM, "1024")
    field(FTVL, "ULONG")
}

## card_id, card_address, num_values, transfer_type, value1, value2, ...
record(waveform, "$(P)$(Q)QXWRITEARRAY")
{
    field(DESC, "QXWriteArray")
    field(NELM, "1028")
    field(FTVL, "ULONG")
    field(DTYP, "asynInt32ArrayOut")
    field(INP,  "@asyn(icp,0,0)QXWRITEARRAY")
}

record(bo, "$(P)$(Q)BLOCKSPECZERO:SP")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(icp,0,0)BLOCKSPECZERO")
	field(ZNAM, "No")
	field(ONAM, "Yes")
	field(PINI, "YES")
    info(autosaveFields, "VAL")
}

record(bi, "$(P)$(Q)BLOCKSPECZERO")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(icp,0,0)BLOCKSPECZERO")
    field(SCAN, "I/O Intr")
	field(ZNAM, "No")
	field(ONAM, "Yes")
}

record(waveform, "$(P)$(Q)SPECINTEGRALS")
{
    field(DESC, "Spec Integrals")
    field(NELM, "$(SPECINTG_SIZE=1000000)")
    field(FTVL, "LONG")
    field(DTYP, "asynInt32ArrayIn")
    field(INP,  "@asyn(icp,0,0)SPECTRUM_INTEGRALS")
    field(SCAN, "I/O Intr")
}

# Normally Passive SCAN and force a scan/read by writing to .PROC
record(waveform, "$(P)$(Q)SPECDATA")
{
    field(DESC, "Spec Data")
    field(NELM, "$(SPECDATA_SIZE=5000000)")
    field(SCAN, "$(SPECDATA_SCAN=Passive)")
    field(FTVL, "LONG")
    field(DTYP, "asynInt32ArrayIn")
    field(INP,  "@asyn(icp,0,0)SPECTRUM_DATA")
}
