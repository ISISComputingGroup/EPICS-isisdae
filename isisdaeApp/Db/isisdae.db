record(waveform, "$(P)$(Q)TITLE")
{
    field(DESC, "Run title")
    field(NELM, "256")
    field(FTVL, "CHAR")
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(icp,0,0)RUNTITLE")
    field(SCAN, "I/O Intr")
    info(INTEREST, "HIGH")
    info(archive, "VAL")
}

## can set DAEPINI to not process this if e.g. it is running with SECI 
record(waveform, "$(P)$(Q)TITLE:SP")
{
    field(DESC, "Set Run title")
    field(NELM, "256")
    field(FTVL, "CHAR")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(icp,0,0)RUNTITLESP")
    field(PINI, "$(DAEPINI=YES)")
    info(autosaveFields, "VAL")
}

record(bi, "$(P)$(Q)TITLE:DISPLAY")
{
    field(DESC, "Toggle Run Title Display")
    field(DTYP, "Soft Channel")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(SCAN, "Passive")
    info(archive, "VAL")
    info(autosaveFields, "VAL")
}

alias("$(P)$(Q)TITLE", "$(P)$(Q)TITLE:SP:RBV")

record(stringin, "$(P)$(Q)_RBNUMBER")
{
    field(DESC, "Experiment (RB) Number")
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(icp,0,0)RBNUMBER")
    field(SCAN, "I/O Intr")
    info(archive, "VAL")
}

record(stringout, "$(P)$(Q)_RBNUMBER:SP")
{
    field(DESC, "Set Experiment (RB) Number")
    field(DTYP, "asynOctetWrite")
    field(OUT,  "@asyn(icp,0,0)RBNUMBER")
    info(autosaveFields, "VAL")
}

alias("$(P)$(Q)_RBNUMBER", "$(P)$(Q)_RBNUMBER:SP:RBV")

record(stringin, "$(P)$(Q)RUNNUMBER")
{
    field(DESC, "Run Number")
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(icp,0,0)RUNNUMBER")
    field(SCAN, "I/O Intr")
    info(INTEREST, "HIGH")
    info(archive, "VAL")
}

record(longin, "$(P)$(Q)IRUNNUMBER")
{
    field(DESC, "Run Number")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(icp,0,0)IRUNNUMBER")
    field(SCAN, "I/O Intr")
    info(INTEREST, "MEDIUM")
	info(archive, "VAL")
	field(EGU, "")
}

record(waveform, "$(P)$(Q)_USERNAME")
{
    field(DESC, "Experiment User name")
    field(NELM, "1024")
    field(FTVL, "CHAR")
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(icp,0,0)USERNAME")
    field(SCAN, "I/O Intr")
    info(archive, "VAL")
}

record(waveform, "$(P)$(Q)_USERNAME:SP")
{
    field(DESC, "Set Experiment User name")
    field(NELM, "1024")
    field(FTVL, "CHAR")
    field(DTYP, "asynOctetWrite")
    field(INP, "@asyn(icp,0,0)USERNAME")
    info(autosaveFields, "VAL")
}

alias("$(P)$(Q)_USERNAME", "$(P)$(Q)_USERNAME:SP:RBV")

record(stringin, "$(P)$(Q)INSTNAME")
{
    field(DESC, "Instrument Name")
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(icp,0,0)INSTNAME")
    field(SCAN, "I/O Intr")
    info(INTEREST, "HIGH")
}

record(stringin, "$(P)$(Q)STARTTIME")
{
    field(DESC, "Run Start Time")
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(icp,0,0)STARTTIME")
    field(SCAN, "I/O Intr")
    info(INTEREST, "HIGH")
    info(archive, "VAL")
}

record(ai, "$(P)$(Q)NPRATIO")
{
    field(DESC, "Neutron/Proton ratio")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(icp,0,0)NPRATIO")
    field(SCAN, "I/O Intr")
	field(EGU, "")
    info(INTEREST, "HIGH")
}

record(stringin, "$(P)$(Q)DAETIMINGSOURCE")
{
    field(DESC, "DAE Timing Source")
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(icp,0,0)DAETIMINGSOURCE")
    field(SCAN, "I/O Intr")
    info(INTEREST, "HIGH")
    info(archive, "VAL")
}

record(stringin, "$(P)$(Q)PERIODTYPE")
{
    field(DESC, "DAE Period Type")
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(icp,0,0)PERIODTYPE")
    field(SCAN, "I/O Intr")
    info(INTEREST, "HIGH")
}

record(stringin, "$(P)$(Q)ISISCYCLE")
{
    field(DESC, "ISIS Run Cycle")
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(icp,0,0)ISISCYCLE")
    field(SCAN, "I/O Intr")
    info(INTEREST, "HIGH")
}

record(longin, "$(P)$(Q)RAWFRAMES")
{
    field(DESC, "Raw Frames")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(icp,0,0)RAWFRAMES")
    field(SCAN, "I/O Intr")
    info(INTEREST, "HIGH")
	field(EGU, "")
    info(archive, "-5.0 VAL")
}

record(longin, "$(P)$(Q)RAWFRAMES_PD")
{
    field(DESC, "Period Raw Frames")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(icp,0,0)RAWFRAMESPD")
    field(SCAN, "I/O Intr")
    info(archive, "-5.0 VAL")
}

record(longin, "$(P)$(Q)GOODFRAMES")
{
    field(DESC, "Good Frames")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(icp,0,0)GOODFRAMES")
    field(SCAN, "I/O Intr")
    info(INTEREST, "HIGH")
	field(EGU, "")
    info(archive, "-5.0 VAL")
}

record(longin, "$(P)$(Q)GOODFRAMES_PD")
{
    field(DESC, "Period Good Frames")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(icp,0,0)GOODFRAMESPD")
    field(SCAN, "I/O Intr")
    info(archive, "-5.0 VAL")
}

record(longin, "$(P)$(Q)RUNDURATION")
{
    field(DESC, "Run Duration")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(icp,0,0)RUNDURATION")
    field(SCAN, "I/O Intr")
    info(INTEREST, "HIGH")
	field(EGU, "s")
    info(archive, "-30.0 VAL")
}

record(longin, "$(P)$(Q)RUNDURATION_PD")
{
    field(DESC, "Period Run Duration")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(icp,0,0)RUNDURATIONPD")
    field(SCAN, "I/O Intr")
    info(archive, "-30.0 VAL")
}

record(longin, "$(P)$(Q)NUMTIMECHANNELS")
{
    field(DESC, "Number of Histogram Time Channels")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(icp,0,0)NUMTIMECHANNELS")
    field(SCAN, "I/O Intr")
    info(INTEREST, "HIGH")
	field(EGU, "")
    info(archive, "VAL")
}

record(longin, "$(P)$(Q)DAEMEMORYUSED")
{
    field(DESC, "DAE Memory Used")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(icp,0,0)DAEMEMORYUSED")
    field(SCAN, "I/O Intr")
    info(INTEREST, "HIGH")
	field(EGU, "byte")
    info(archive, "VAL")
}

record(longin, "$(P)$(Q)NUMSPECTRA")
{
    field(DESC, "Number of DAE Spectra")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(icp,0,0)NUMSPECTRA")
    field(SCAN, "I/O Intr")
    info(INTEREST, "HIGH")
	field(EGU, "")	
    info(archive, "VAL")
}

record(longin, "$(P)$(Q)MONITORCOUNTS")
{
    field(DESC, "Displayed Monitor Counts")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(icp,0,0)MONITORCOUNTS")
    field(SCAN, "I/O Intr")
    info(INTEREST, "HIGH")
	field(EGU, "count")
    info(archive, "VAL")
}

record(longin, "$(P)$(Q)MONITORSPECTRUM")
{
    field(DESC, "Displayed Monitor Spectrum Number")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(icp,0,0)MONITORSPECTRUM")
    field(SCAN, "I/O Intr")
    info(INTEREST, "HIGH")
	field(EGU, "")
    info(archive, "VAL")
}

record(longin, "$(P)$(Q)PERIODSEQ")
{
    field(DESC, "Number of Hardware Period Sequences")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(icp,0,0)PERIODSEQ")
    field(SCAN, "I/O Intr")
    info(INTEREST, "HIGH")
	field(EGU, "")
    info(archive, "VAL")
}

record(ai, "$(P)$(Q)BEAMCURRENT")
{
    field(DESC, "DAE Effective Beam Current")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(icp,0,0)BEAMCURRENT")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
    info(INTEREST, "HIGH")
	field(EGU, "uA")
    info(archive, "-5.0 VAL")
}

record(ai, "$(P)$(Q)TOTALUAMPS")
{
    field(DESC, "DAE Raw Microamps")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(icp,0,0)TOTALUAMPS")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
    info(INTEREST, "HIGH")
	field(EGU, "uA hour")
    info(archive, "-5.0 VAL")
}

record(ai, "$(P)$(Q)MEVENTS")
{
    field(DESC, "DAE millions of events")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(icp,0,0)MEVENTS")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
    info(INTEREST, "HIGH")
    info(archive, "-5.0 VAL")
	field(EGU, "Mevent")
}

## historical alias
record(ai, "$(P)$(Q)TOTALDAECOUNTS")
{
    field(DESC, "DAE millions of counts")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(icp,0,0)MEVENTS")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
    info(archive, "-5.0 VAL")
	field(EGU, "Mcount")
}

record(ai, "$(P)$(Q)MONITORTO")
{
    field(DESC, "Display Monitor High Integral time")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(icp,0,0)MONITORTO")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
	field(EGU, "us")
    info(archive, "VAL EGU")
}

record(ai, "$(P)$(Q)MONITORFROM")
{
    field(DESC, "Display Monitor Low Integral time")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(icp,0,0)MONITORFROM")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
	field(EGU, "us")
    info(archive, "VAL EGU")
}

record(ai, "$(P)$(Q)COUNTRATE")
{
    field(DESC, "DAE Count Rate")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(icp,0,0)COUNTRATE")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
	field(EGU, "")
    info(INTEREST, "HIGH")
    info(archive, "-5.0 VAL")
}

record(ai, "$(P)$(Q)COUNTRATEFRAME")
{
    field(DESC, "DAE Count Rate")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(icp,0,0)COUNTRATEFRAME")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
	field(EGU, "")
    info(INTEREST, "HIGH")
    info(archive, "-5.0 VAL")
}

record(ai, "$(P)$(Q)EVENTMODEFRACTION")
{
    field(DESC, "Event Mode DAE Card Fraction")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(icp,0,0)EVENTMODEFRACTION")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
    info(INTEREST, "HIGH")
	field(EGU, "")
}

record(ai, "$(P)$(Q)EVENTMODEBUFUSED")
{
    field(DESC, "Event Mode Buffer used Fraction")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(icp,0,0)EVENTMODEBUFFERUSED")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
    info(INTEREST, "HIGH")
	field(EGU, "")
}

record(ai, "$(P)$(Q)EVENTMODEFILEMB")
{
    field(DESC, "Event Mode File Size")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(icp,0,0)EVENTMODEFILEMB")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
    info(INTEREST, "HIGH")
	field(EGU, "MB")
}

record(ai, "$(P)$(Q)EVENTMODEDATARATE")
{
    field(DESC, "Event Mode Data Rate")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(icp,0,0)EVENTMODEDATARATE")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
    info(INTEREST, "HIGH")
	field(EGU, "MB /s")
}

record(ai, "$(P)$(Q)GOODUAH")
{
    field(DESC, "DAE Good Microamps")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(icp,0,0)GOODUAH")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
    info(INTEREST, "HIGH")
	field(EGU, "uA hour")
    info(archive, "-5.0 VAL")
}

record(ai, "$(P)$(Q)GOODUAH_PD")
{
    field(DESC, "Period DAE Good Microamps")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(icp,0,0)GOODUAHPD")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
	field(EGU, "uA hour")
    info(archive, "-5.0 VAL")
}

record(bo, "$(P)$(Q)BEGINRUN")
{
    field(DESC, "Begin a Run")
    field(ZNAM, "0")
    field(ONAM, "1")
    #Set the initial alarm state
    field(STAT, "NO_ALARM")
	field(FLNK, "$(BEGINRUNA=$(P)$(Q)_BEGINRUN1).PROC")
}

record(longout, "$(P)$(Q)_BEGINRUN1")
{
    field(OUT, "$(P)CS:RC:SYNC:SP PP")
	field(VAL, 1)
    field(FLNK, "$(P)$(Q)_BEGINRUN2.PROC")
}

record(bo, "$(P)$(Q)_BEGINRUN2")
{
    field(DESC, "Begin a Run")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(icp,0,0)BEGINRUN")
    field(ZNAM, "0")
    field(ONAM, "1")
	field(VAL, 1)
    field(FLNK, "$(P)$(Q)_BEGINRUN3")
}

record(fanout, "$(P)$(Q)_BEGINRUN3") {
    field(LNK1, "$(P)$(Q)_RESTART_ARCHIVER.PROC")
    field(LNK2, "$(POST_BEGIN_1=)")
    field(LNK3, "$(POST_BEGIN_2=)")
    field(LNK4, "$(POST_BEGIN_3=)")
    field(LNK5, "$(POST_BEGIN_4=)")
}

## value sent controls begin options (such as DELAYED or PAUSED)
record(longout, "$(P)$(Q)BEGINRUNEX")
{
    field(DESC, "Begin a Run (with options)")
    #Set the initial alarm state
    field(STAT, "NO_ALARM")
    field(FLNK, "$(P)$(Q)_BEGINRUNEX1.PROC")
}

record(longout, "$(P)$(Q)_BEGINRUNEX1")
{
    field(OUT, "$(P)CS:RC:SYNC:SP PP")
	field(VAL, 1)
    field(FLNK, "$(P)$(Q)_BEGINRUNEX2.PROC")
}

record(longout, "$(P)$(Q)_BEGINRUNEX2")
{
    field(DESC, "Begin a Run (with options)")
	field(DOL, "$(P)$(Q)BEGINRUNEX")
	field(OMSL, "closed_loop")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(icp,0,0)BEGINRUNEX")
    field(FLNK, "$(P)$(Q)_BEGINRUN3")
}

record(bo, "$(P)$(Q)ABORTRUN")
{
    field(DESC, "Abort a Run")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(icp,0,0)ABORTRUN")
    field(ZNAM, "0")
    field(ONAM, "1")
    #Set the initial alarm state
    field(STAT, "NO_ALARM")
    field(FLNK, "$(P)$(Q)ABORTRUN:_POSTACTIONS")
}

record(fanout, "$(P)$(Q)ABORTRUN:_POSTACTIONS") {
    field(LNK1, "$(POST_ABORT_1)")
    field(LNK2, "$(POST_ABORT_2)")
    field(LNK3, "$(POST_ABORT_3)")
    field(LNK4, "$(POST_ABORT_4)")
}

record(bo, "$(P)$(Q)PAUSERUN")
{
    field(DESC, "Pause a Run")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(icp,0,0)PAUSERUN")
    field(ZNAM, "0")
    field(ONAM, "1")
    #Set the initial alarm state
    field(STAT, "NO_ALARM")
    field(FLNK, "$(P)$(Q)PAUSERUN:_POSTACTIONS")
}

record(fanout, "$(P)$(Q)PAUSERUN:_POSTACTIONS") {
    field(LNK1, "$(POST_PAUSE_1)")
    field(LNK2, "$(POST_PAUSE_2)")
    field(LNK3, "$(POST_PAUSE_3)")
    field(LNK4, "$(POST_PAUSE_4)")
}

record(bo, "$(P)$(Q)RESUMERUN")
{
    field(DESC, "Resume a Run")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(icp,0,0)RESUMERUN")
    field(ZNAM, "0")
    field(ONAM, "1")
    #Set the initial alarm state
    field(STAT, "NO_ALARM")
    field(FLNK, "$(P)$(Q)RESUMERUN:_POSTACTIONS")
}

record(fanout, "$(P)$(Q)RESUMERUN:_POSTACTIONS") {
    field(LNK1, "$(POST_RESUME_1)")
    field(LNK2, "$(POST_RESUME_2)")
    field(LNK3, "$(POST_RESUME_3)")
    field(LNK4, "$(POST_RESUME_4)")
}

record(bo, "$(P)$(Q)ENDRUN")
{
    field(DESC, "End a Run")
    field(ZNAM, "0")
    field(ONAM, "1")
    #Set the initial alarm state
    field(STAT, "NO_ALARM")
    field(FLNK, "$(ENDRUNA=$(P)$(Q)_ENDRUN1).PROC")
}

record(seq, "$(P)$(Q)_ENDRUN1")
{
	field(SELM, "All")
	field(DOL1, "1")
	field(DOL2, "1")
	# give archive time to restart
	field(DLY2, "1")
    field(LNK1, "$(P)$(Q)_RESTART_ARCHIVER.PROC")
    field(LNK2, "$(P)$(Q)_ENDRUN2 PP")
    field(LNK3, "$(POST_END_1=)")
    field(LNK4, "$(POST_END_2=)")
    field(LNK5, "$(POST_END_3=)")
    field(LNK6, "$(POST_END_4=)")
}

record(bo, "$(P)$(Q)_ENDRUN2")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(icp,0,0)ENDRUN")
    field(ZNAM, "0")
    field(ONAM, "1")
    #Set the initial alarm state
    field(STAT, "NO_ALARM")
}

record(bo, "$(P)$(Q)RECOVERRUN")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(icp,0,0)RECOVERRUN")
    field(ZNAM, "0")
    field(ONAM, "1")
    #Set the initial alarm state
    field(STAT, "NO_ALARM")
}

record(bo, "$(P)$(Q)SAVERUN")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(icp,0,0)SAVERUN")
    field(ZNAM, "0")
    field(ONAM, "1")
    #Set the initial alarm state
    field(STAT, "NO_ALARM")
}

record(bo, "$(P)$(Q)UPDATERUN")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(icp,0,0)UPDATERUN")
    field(ZNAM, "0")
    field(ONAM, "1")
    #Set the initial alarm state
    field(STAT, "NO_ALARM")
}

record(bo, "$(P)$(Q)STORERUN")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(icp,0,0)STORERUN")
    field(ZNAM, "0")
    field(ONAM, "1")
    #Set the initial alarm state
    field(STAT, "NO_ALARM")
}

record(waveform, "$(P)$(Q)SNAPSHOTCRPT")
{
    field(NELM, "1024")
    field(FTVL, "CHAR")
    field(DTYP, "asynOctetWrite")
    field(INP, "@asyn(icp,0,0)SNAPSHOTCRPT")
    #Set the initial alarm state
    field(STAT, "NO_ALARM")
}

record(bo, "$(P)$(Q)SEWAIT")
{
    field(DTYP, "asynInt32")
    field(ZNAM, "0")
    field(ONAM, "1")
    field(OUT,  "@asyn(icp,0,0)SEWAIT")
}

## show number of seconds in WAITING state
record(ai, "$(P)$(Q)WAITING:TIME")
{
    field(VAL, "0")
    field(DESC, "Time in WAITING state")
	field(EGU, "s")
	field(PREC, "1")
}

## calculate number of seconds in WAITING state
record(calcout, "$(P)$(Q)WAITING:TIME:_CALC")
{
    field(INPA, "$(P)$(Q)RUNSTATE NPP")
    field(INPB, "$(P)$(Q)WAITING:TIME NPP")
	field(CALC, "A = 4 ? B + 1 : 0")
	field(OOPT, "On Change")
    field(OUT, "$(P)$(Q)WAITING:TIME PP")
    field(SCAN, "1 second")
}

## 2 for RUNNING and 4 for WAITING are used in a runcontrol check, so be careful about changing numbers
record(mbbi, "$(P)$(Q)RUNSTATE")
{
    field(DESC, "Run State (Integer/Enum)")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(icp,0,0)RUNSTATUS")
    field(SCAN, "I/O Intr")
    field(ZRVL, 0)
    field(ZRST, "PROCESSING")
    field(ONVL, 1)
    field(ONST, "SETUP")
    field(TWVL, 2)
    field(TWST, "RUNNING")
    field(THVL, 3)
    field(THST, "PAUSED")
    field(FRVL, 4)
    field(FRST, "WAITING")
    field(FVVL, 5)
    field(FVST, "VETOING")
    field(SXVL, 6)
    field(SXST, "ENDING")
    field(SVVL, 7)
    field(SVST, "SAVING")
    field(EIVL, 8)
    field(EIST, "RESUMING")
    field(NIVL, 9)
    field(NIST, "PAUSING")
    field(TEVL, 10)
    field(TEST, "BEGINNING")
    field(ELVL, 11)
    field(ELST, "ABORTING")
    field(TVVL, 12)
    field(TVST, "UPDATING")
    field(TTVL, 13)
    field(TTST, "STORING")
    field(FTVL, 14)
    field(FTST, "CHANGING")
    info(INTEREST, "HIGH")
    info(archive, "VAL")
}

record(stringin, "$(P)$(Q)RUNSTATE_STR")
{
    field(DESC, "Run State (String)")
    field(INP, "$(P)$(Q)RUNSTATE CP")
    info(INTEREST, "HIGH")
    info(archive, "VAL")
}

record(bi, "$(P)$(Q)STATETRANS")
{
    field(DESC, "In state transition")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(icp,0,0)STATETRANS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(SCAN, "I/O Intr")
}

# in CHANGING run state, workaround
record(bi, "$(P)$(Q)STATE:CHANGING")
{
    field(DESC, "In changing state")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(icp,0,0)INCHANGINGSTATE")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(SCAN, "I/O Intr")
}

# number of seconds in transition state
record(ai, "$(P)$(Q)STATETRANS:TIME")
{
    field(VAL, "0")
    field(DESC, "Time in state transition")
	field(EGU, "s")
	field(PREC, "1")
}

# calculate number of seconds in transition state
record(calcout, "$(P)$(Q)STATETRANS:TIME:_CALC")
{
    field(INPA, "$(P)$(Q)STATETRANS NPP")
    field(INPB, "$(P)$(Q)STATETRANS:TIME NPP")
	field(CALC, "A != 0 ? B + 1 : 0")
	field(OOPT, "On Change")
    field(OUT, "$(P)$(Q)STATETRANS:TIME PP")
    field(SCAN, "1 second")
}

record(longin, "$(P)$(Q)PERIOD")
{
    field(DESC, "DAE Period Number")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(icp,0,0)PERIOD")
    field(SCAN, "I/O Intr")
    info(INTEREST, "HIGH")
	info(archive, "VAL")
	field(EGU, "")
}

record(longout, "$(P)$(Q)PERIOD:SP")
{
    field(DESC, "Change DAE Period Number")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(icp,0,0)PERIOD")
}

alias("$(P)$(Q)PERIOD", "$(P)$(Q)PERIOD:SP:RBV")

record(longin, "$(P)$(Q)NUMPERIODS")
{
    field(DESC, "Number of DAE periods")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(icp,0,0)NUMPERIODS")
    field(SCAN, "I/O Intr")
    info(INTEREST, "HIGH")
	field(EGU, "")
	info(archive, "VAL")
}

record(longout, "$(P)$(Q)NUMPERIODS:SP")
{
    field(DESC, "Change Number of DAE periods")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(icp,0,0)NUMPERIODS")
}

alias("$(P)$(Q)NUMPERIODS", "$(P)$(Q)NUMPERIODS:SP:RBV")

record(longin, "$(P)$(Q)TOTALCOUNTS")
{
    field(DESC, "Total counts")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(icp,0,0)TOTALCOUNTS")
    field(SCAN, "I/O Intr")
    info(INTEREST, "HIGH")
	field(EGU, "count")
    info(archive, "-5.0 VAL")
}

# historical alias
record(longin, "$(P)$(Q)EVENTS")
{
    field(DESC, "Total counts")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(icp,0,0)TOTALCOUNTS")
    field(SCAN, "I/O Intr")
	field(EGU, "event")
    info(archive, "-5.0 VAL")
}

record(waveform, "$(P)$(Q)DAESETTINGS")
{
    field(NELM, "10000")
    field(FTVL, "CHAR")
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(icp,0,0)DAESETTINGS")
    field(SCAN, "I/O Intr")
}

record(waveform, "$(P)$(Q)DAESETTINGS:SP")
{
    field(NELM, "10000")
    field(FTVL, "CHAR")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(icp,0,0)DAESETTINGS")
}

record(waveform, "$(P)$(Q)TCBSETTINGS")
{
    field(NELM, "10000")
    field(FTVL, "UCHAR")
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(icp,0,0)TCBSETTINGS")
    field(SCAN, "I/O Intr")
}

record(waveform, "$(P)$(Q)TCBSETTINGS:SP")
{
    field(NELM, "10000")
    field(FTVL, "UCHAR")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(icp,0,0)TCBSETTINGS")
}

record(waveform, "$(P)$(Q)HARDWAREPERIODS")
{
    field(NELM, "10000")
    field(FTVL, "CHAR")
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(icp,0,0)HARDWAREPERIODSSETTINGS")
    field(SCAN, "I/O Intr")
}

record(waveform, "$(P)$(Q)HARDWAREPERIODS:SP")
{
    field(NELM, "10000")
    field(FTVL, "CHAR")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(icp,0,0)HARDWAREPERIODSSETTINGS")
}

record(waveform, "$(P)$(Q)UPDATESETTINGS")
{
    field(NELM, "10000")
    field(FTVL, "CHAR")
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(icp,0,0)UPDATESETTINGS")
    field(SCAN, "I/O Intr")
}

record(waveform, "$(P)$(Q)UPDATESETTINGS:SP")
{
    field(NELM, "10000")
    field(FTVL, "CHAR")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(icp,0,0)UPDATESETTINGS")
}

record(waveform, "$(P)$(Q)VETOSTATUS")
{
    field(NELM, "3000")
    field(FTVL, "CHAR")
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(icp,0,0)VETOSTATUS")
    field(SCAN, "I/O Intr")
}

record(ai, "$(P)$(Q)VETOPC")
{
    field(DESC, "Vetoing %")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(icp,0,0)VETOPC")
    field(SCAN, "I/O Intr")
	field(EGU, "%")
# useful to log, but need a good deadband value or will get too much data
	field(ADEL, 5.0)
	info(archive, "-5.0 VAL")
}

record(stringout, "$(P)$(Q)VETO:ENABLE:SP")
{
    field(DESC, "Enable veto")
    field(DTYP, "asynOctetWrite")
    field(OUT,  "@asyn(icp,0,0)VETO_ENABLE")
    info(archive, "VAL")
}

record(stringout, "$(P)$(Q)VETO:DISABLE:SP")
{
    field(DESC, "Disable veto")
    field(DTYP, "asynOctetWrite")
    field(OUT,  "@asyn(icp,0,0)VETO_DISABLE")
    info(archive, "VAL")
}

record(waveform, "$(P)$(Q)ALLMSGS")
{
    field(NELM, "4096")
    field(FTVL, "CHAR")
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(icp,0,0)ALLMSGS")
    field(SCAN, "I/O Intr")
}

record(waveform, "$(P)$(Q)ERRMSGS")
{
    field(NELM, "4096")
    field(FTVL, "CHAR")
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(icp,0,0)ERRMSGS")
    field(SCAN, "I/O Intr")
}

record(waveform, "$(P)$(Q)WIRING_FILE")
{
   field(DESC, "Wiring table filename")
   field(DTYP, "asynOctetRead")
   field(INP, "@asyn(icp,0,0)WIRINGFILE")
   field(SCAN, "I/O Intr")
   field(FTVL, "CHAR")
   field(NELM, 256)
}

record(waveform, "$(P)$(Q)DETECTOR_FILE")
{
   field(DESC, "Detector table filename")
   field(DTYP, "asynOctetRead")
   field(INP, "@asyn(icp,0,0)DETFILE")
   field(SCAN, "I/O Intr")
   field(FTVL, "CHAR")
   field(NELM, 256)
}

record(waveform, "$(P)$(Q)SPECTRA_FILE")
{
   field(DESC, "Spectra table filename")
   field(DTYP, "asynOctetRead")
   field(INP, "@asyn(icp,0,0)SPECFILE")
   field(SCAN, "I/O Intr")
   field(FTVL, "CHAR")
   field(NELM, 256)
}

record(waveform, "$(P)$(Q)TCB_FILE")
{
   field(DESC, "TCB filename")
   field(DTYP, "asynOctetRead")
   field(INP, "@asyn(icp,0,0)TCBFILE")
   field(SCAN, "I/O Intr")
   field(FTVL, "CHAR")
   field(NELM, 256)
}

record(waveform, "$(P)$(Q)PERIOD_FILE")
{
   field(DESC, "Periods filename")
   field(DTYP, "asynOctetRead")
   field(INP, "@asyn(icp,0,0)PERIODSFILE")
   field(SCAN, "I/O Intr")
   field(FTVL, "CHAR")
   field(NELM, 256)
}

##############################################################################################
## FileList for wiring tables
##############################################################################################

record(waveform, "$(P)$(Q)WIRING_DIR:SP")
{
   field(DESC, "Set directory of wiring tables")
   field(DTYP, "asynOctetWrite")
   field(INP, "@asyn($(WIRINGLIST),0,1)DIRBASE")
   field(FTVL, "CHAR")
   field(NELM, 256)
}

record(waveform, "$(P)$(Q)WIRING_DIR")
{
   field(DESC, "Get directory of wiring tables")
   field(DTYP, "asynOctetRead")
   field(INP, "@asyn($(WIRINGLIST),0,1)DIRBASE")
   field(SCAN, "I/O Intr")
   field(PINI, "YES")
   field(FTVL, "CHAR")
   field(NELM, 256)
}

record(waveform, "$(P)$(Q)WIRINGTABLES")
{
	field(DESC, "Compressed JSON list of wiring tables")
	field(FTVL, "CHAR")
	field(DTYP, "asynOctetRead")
    field(INP, "@asyn($(WIRINGLIST),0,1)JARR")	
	field(NELM, 16384)
	field(SCAN, "I/O Intr")
    field(PINI, "YES")
}

record(waveform, "$(P)$(Q)WIRING_PATTERN:SP")
{
   field(DESC, "Set regex search of wiring tables")  
   field(DTYP, "asynOctetWrite")
   field(INP, "@asyn($(WIRINGLIST),0,1)SEARCH")
   field(FTVL, "CHAR")
   field(NELM, 256)
}
record(waveform, "$(P)$(Q)WIRING_PATTERN")
{
   field(DESC, "Get regex search of wiring tables")
   field(DTYP, "asynOctetRead")
   field(INP, "@asyn($(WIRINGLIST),0,1)SEARCH")
   field(SCAN, "I/O Intr")
   field(PINI, "YES")
   field(FTVL, "CHAR")
   field(NELM, 256)
}

##############################################################################################
## FileList for detector tables
##############################################################################################

record(waveform, "$(P)$(Q)DETECTOR_DIR:SP")
{
   field(DESC, "Set directory of detector tables")
   field(DTYP, "asynOctetWrite")
   field(INP, "@asyn($(DETECTORLIST),0,1)DIRBASE")
   field(FTVL, "CHAR")
   field(NELM, 256)
}

record(waveform, "$(P)$(Q)DETECTOR_DIR")
{
   field(DESC, "Get directory of detector tables")
   field(DTYP, "asynOctetRead")
   field(INP, "@asyn($(DETECTORLIST),0,1)DIRBASE")
   field(SCAN, "I/O Intr")
   field(PINI, "YES")
   field(FTVL, "CHAR")
   field(NELM, 256)
}

record(waveform, "$(P)$(Q)DETECTORTABLES")
{
	field(DESC, "Compressed JSON list of detector tables")
	field(FTVL, "CHAR")
	field(DTYP, "asynOctetRead")
    field(INP, "@asyn($(DETECTORLIST),0,1)JARR")	
	field(NELM, 16384)
	field(SCAN, "I/O Intr")
    field(PINI, "YES")
}

record(waveform, "$(P)$(Q)DETECTOR_PATTERN:SP")
{
   field(DESC, "Set regex search of detector tables")  
   field(DTYP, "asynOctetWrite")
   field(INP, "@asyn($(DETECTORLIST),0,1)SEARCH")
   field(FTVL, "CHAR")
   field(NELM, 256)
}
record(waveform, "$(P)$(Q)DETECTOR_PATTERN")
{
   field(DESC, "Get regex search of detector tables")
   field(DTYP, "asynOctetRead")
   field(INP, "@asyn($(DETECTORLIST),0,1)SEARCH")
   field(SCAN, "I/O Intr")
   field(PINI, "YES")
   field(FTVL, "CHAR")
   field(NELM, 256)
}

##############################################################################################
## FileList parameters for spectra tables
##############################################################################################

record(waveform, "$(P)$(Q)SPECTRA_DIR:SP")
{
   field(DESC, "Set directory of spectra tables")
   field(DTYP, "asynOctetWrite")
   field(INP, "@asyn($(SPECTRALIST),0,1)DIRBASE")
   field(FTVL, "CHAR")
   field(NELM, 256)
}

record(waveform, "$(P)$(Q)SPECTRA_DIR")
{
   field(DESC, "Get directory of spectra tables")
   field(DTYP, "asynOctetRead")
   field(INP, "@asyn($(SPECTRALIST),0,1)DIRBASE")
   field(SCAN, "I/O Intr")
   field(PINI, "YES")
   field(FTVL, "CHAR")
   field(NELM, 256)
}

record(waveform, "$(P)$(Q)SPECTRATABLES")
{
	field(DESC, "Compressed JSON list of spectra tables")
	field(FTVL, "CHAR")
	field(DTYP, "asynOctetRead")
    field(INP, "@asyn($(SPECTRALIST),0,1)JARR")	
	field(NELM, 16384)
	field(SCAN, "I/O Intr")
    field(PINI, "YES")
}

record(waveform, "$(P)$(Q)SPECTRA_PATTERN:SP")
{
   field(DESC, "Set regex search of spectra tables")  
   field(DTYP, "asynOctetWrite")
   field(INP, "@asyn($(SPECTRALIST),0,1)SEARCH")
   field(FTVL, "CHAR")
   field(NELM, 256)
}
record(waveform, "$(P)$(Q)SPECTRA_PATTERN")
{
   field(DESC, "Get regex search of spectra tables")
   field(DTYP, "asynOctetRead")
   field(INP, "@asyn($(SPECTRALIST),0,1)SEARCH")
   field(SCAN, "I/O Intr")
   field(PINI, "YES")
   field(FTVL, "CHAR")
   field(NELM, 256)
}

##############################################################################################
## FileList for TCB files
##############################################################################################

record(waveform, "$(P)$(Q)TCB_DIR:SP")
{
   field(DESC, "Set directory of TCB files")
   field(DTYP, "asynOctetWrite")
   field(INP, "@asyn($(TCBLIST),0,1)DIRBASE")
   field(FTVL, "CHAR")
   field(NELM, 256)
}

record(waveform, "$(P)$(Q)TCB_DIR")
{
   field(DESC, "Get directory of TCB Files")
   field(DTYP, "asynOctetRead")
   field(INP, "@asyn($(TCBLIST),0,1)DIRBASE")
   field(SCAN, "I/O Intr")
   field(PINI, "YES")
   field(FTVL, "CHAR")
   field(NELM, 256)
}

record(waveform, "$(P)$(Q)TCBFILES")
{
	field(DESC, "Compressed JSON list of TCB Files")
	field(FTVL, "CHAR")
	field(DTYP, "asynOctetRead")
    field(INP, "@asyn($(TCBLIST),0,1)JARR")	
	field(NELM, 16384)
	field(SCAN, "I/O Intr")
    field(PINI, "YES")
}

record(waveform, "$(P)$(Q)TCB_PATTERN:SP")
{
   field(DESC, "Set regex search of TCB files")  
   field(DTYP, "asynOctetWrite")
   field(INP, "@asyn($(TCBLIST),0,1)SEARCH")
   field(FTVL, "CHAR")
   field(NELM, 256)
}
record(waveform, "$(P)$(Q)TCB_PATTERN")
{
   field(DESC, "Get regex search of TCB files")
   field(DTYP, "asynOctetRead")
   field(INP, "@asyn($(TCBLIST),0,1)SEARCH")
   field(SCAN, "I/O Intr")
   field(PINI, "YES")
   field(FTVL, "CHAR")
   field(NELM, 256)
}

##############################################################################################
## FileList parameters for period files
##############################################################################################

record(waveform, "$(P)$(Q)PERIOD_DIR:SP")
{
   field(DESC, "Set directory of period files")
   field(DTYP, "asynOctetWrite")
   field(INP, "@asyn($(PERIODLIST),0,1)DIRBASE")
   field(FTVL, "CHAR")
   field(NELM, 256)
}

record(waveform, "$(P)$(Q)PERIOD_DIR")
{
   field(DESC, "Get directory of period files")
   field(DTYP, "asynOctetRead")
   field(INP, "@asyn($(PERIODLIST),0,1)DIRBASE")
   field(SCAN, "I/O Intr")
   field(PINI, "YES")
   field(FTVL, "CHAR")
   field(NELM, 256)
}

record(waveform, "$(P)$(Q)PERIODFILES")
{
	field(DESC, "Compressed JSON list of period files")
	field(FTVL, "CHAR")
	field(DTYP, "asynOctetRead")
    field(INP, "@asyn($(PERIODLIST),0,1)JARR")	
	field(NELM, 16384)
	field(SCAN, "I/O Intr")
    field(PINI, "YES")
}

record(waveform, "$(P)$(Q)PERIOD_PATTERN:SP")
{
   field(DESC, "Set regex search of period files")  
   field(DTYP, "asynOctetWrite")
   field(INP, "@asyn($(PERIODLIST),0,1)SEARCH")
   field(FTVL, "CHAR")
   field(NELM, 256)
}
record(waveform, "$(P)$(Q)PERIOD_PATTERN")
{
   field(DESC, "Get regex search of period files")
   field(DTYP, "asynOctetRead")
   field(INP, "@asyn($(PERIODLIST),0,1)SEARCH")
   field(SCAN, "I/O Intr")
   field(PINI, "YES")
   field(FTVL, "CHAR")
   field(NELM, 256)
}

##############################################################################################
## records for restarting archive engine on a begin
##############################################################################################

## force processing of _RESTART_ARCHIVER via forward link to restart archiver
record(seq, "$(P)$(Q)_RESTART_ARCHIVER")
{
	field(SELM, "All")
	field(DOL1, "1")
	field(DOL2, "1")
    field(LNK1, "$(P)$(Q)_RESTART_ARCHIVER1.PROC")
	field(DLY2, "5.0")
    field(LNK2, "$(P)$(Q)_CHECK_ARCHIVER.PROC")
	field(SCAN, "Passive")
}

## URL for block archiver restart request
record(stringout, "$(P)$(Q)_RESTART_ARCHIVER_URL")
{
    field(DTYP, "asynOctetWrite")
    field(OUT, "@asyn(arch1,0,0)URL0")
	field(PINI, "YES")
	field(VAL, "http://localhost:4813/restart")
}

## ask block archiver to restart
record(stringin, "$(P)$(Q)_RESTART_ARCHIVER1")
{
    field(DTYP, "asynOctetRead")
    field(INP, "@asyn(arch1,0,0)DATA0")
	field(SCAN, "Passive")
}

## URL of block archiver status page
record(stringout, "$(P)$(Q)_CHECK_ARCHIVER_URL")
{
    field(DTYP, "asynOctetWrite")
    field(OUT, "@asyn(arch2,0,0)URL0")
	field(PINI, "YES")
	field(VAL, "http://localhost:4813/main")
}

## XPath expression to check status web page for whether archiver is RUNNING
record(stringout, "$(P)$(Q)_CHECK_ARCHIVER_XPATH")
{
    field(DTYP, "asynOctetWrite")
    field(OUT, "@asyn(arch2,0,0)XPATH0")
	field(PINI, "YES")
	field(VAL, "count(//*[text()='RUNNING'])")
}

## check block archiver status - contains 1 if RUNNING, 0 if not
record(bi, "$(P)$(Q)_CHECK_ARCHIVER")
{
    field(DTYP, "asynInt32")
	field(ZNAM, "STOPPED")
	field(ONAM, "RUNNING")
    field(INP, "@asyn(arch2,0,0)IDATA0")
	field(SCAN, "Passive")
	field(FLNK, "$(P)$(Q)_CHECK_ARCHIVER_CALC.PROC")
}

## if _CHECK_ARCHIVER is 0 (i.e. not RUNNING), signal a hard restart of the block archiver via procServ
record(calcout, "$(P)$(Q)_CHECK_ARCHIVER_CALC")
{
    field(INPA, "$(P)$(Q)_CHECK_ARCHIVER NPP")
    field(INPB, 1)
	field(CALC, "A=B")
	field(OOPT, "When Zero")
	field(OUT, "$(P)$(Q)_RESTART_ARCHIVER_PS.PROC PP")
}

## restart block archiver using procServ via procServControl
record(longout, "$(P)$(Q)_RESTART_ARCHIVER_PS")
{
    field(OUT, "$(P)CS:PS:ARBLOCK:RESTART PP")
    field(VAL, 1)
}

## has simulation mode been enabled in ISISICP
record(bi, "$(P)$(Q)SIM_MODE")
{
    field(DESC, "Is DAE in simulation mode")
    field(DTYP, "asynInt32")
	field(ZNAM, "No")
	field(ONAM, "Yes")
    field(INP, "@asyn(icp,0,0)SIM_MODE")
	field(SCAN, "I/O Intr")
	info(INTEREST, "HIGH")
    info(archive, "VAL")
}

## We use NPP on OUT as the PARS:BL:CURR_CONFIG is already on a periodic
## scan loop to send to isisicp
record(lso, "$(P)$(Q)CURR_CONFIG")
{
    field(DOL, "$(P)CS:BLOCKSERVER:CURR_CONFIG_NAME")
	field(OMSL, "closed_loop")
	field(OUT, "$(P)PARS:BL:CURR_CONFIG NPP")
	field(SCAN, "10 second")
	field(SIZV, "256")
}

record(calcout, "$(P)$(Q)_HRPDINT")
{
    field(INPA, "$(P)$(Q)VETO:EXT3:PC CP")
    field(INPB, "$(P)$(Q)RUNSTATE CP")
    field(CALC, "(B=5||B=2)?(A > 50 ? 0 : 1) : 2")
    field(OUT, "$(P)$(Q)HRPDINT PP")
    field(OOPT, "On Change")
}

record(mbbi, "$(P)$(Q)HRPDINT")
{
    field(ZRVL, 0)
    field(ONVL, 1)
    field(TWVL, 2)
    field(ZRST, "CLOSED")
    field(ONST, "OPEN")
    field(TWST, "UNKNOWN")
    field(ZRSV, "MINOR")
    field(TWSV, "MINOR")
}

record(mbbi, "$(P)$(Q)DAETYPE")
{
    field(DESC, "DAE Type")
    field(ZRVL, 0)
    field(ONVL, 1)
    field(TWVL, 2)
    field(THVL, 3)
    field(FRVL, 4)
    field(ZRST, "Unknown")
    field(ONST, "NeutronDAE2")
    field(TWST, "MuonDAE2")
    field(THST, "NeutronDAE3")
    field(FRST, "MuonDAE3")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(icp,0,0)DAETYPE")
    field(SCAN, "I/O Intr")
}

record(bi, "$(P)$(Q)ISMUON")
{
    field(DESC, "Is Muon DAE?")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(icp,0,0)ISMUONDAE")
    field(SCAN, "I/O Intr")
    field(ZNAM, "No")
    field(ONAM, "Yes")
}

## card_id, card_address, word_size(0=16bit, 1=32 bit)
record(waveform, "$(P)$(Q)VMEREADVALUE:PROPS")
{
    field(DESC, "VMEReadValue props")
    field(NELM, "3")
    field(FTVL, "LONG")
    field(DTYP, "asynInt32ArrayOut")
    field(INP,  "@asyn(icp,0,0)VMEREADVALUEPROPS")
    field(FLNK,  "$(P)$(Q)VMEREADVALUE:DATA")
}

record(longin, "$(P)$(Q)VMEREADVALUE:DATA")
{
    field(DESC, "VMEReadValue data")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(icp,0,0)VMEREADVALUEDATA")
}

## card_id, card_address, word_size (0=16bit, 1=32 bit), mode (0=set,1=and,2=or,3=xor), value
record(waveform, "$(P)$(Q)VMEWRITEVALUE")
{
    field(DESC, "VMEWriteValue")
    field(NELM, "5")
    field(FTVL, "ULONG")
    field(DTYP, "asynInt32ArrayOut")
    field(INP,  "@asyn(icp,0,0)VMEWRITEVALUE")
}

## card_id, card_address, num_values
record(waveform, "$(P)$(Q)VMEREADARRAY:PROPS")
{
    field(DESC, "VMEReadArray props")
    field(NELM, "3")
    field(FTVL, "LONG")
    field(DTYP, "asynInt32ArrayOut")
    field(INP,  "@asyn(icp,0,0)VMEREADARRAYPROPS")
    field(FLNK,  "$(P)$(Q)VMEREADARRAY:DATA")
}

## vme read array does TransferBlock | TransferLittleEndian
## vme read value is TransferIORegisterSpace
## check NORD for how many read
record(waveform, "$(P)$(Q)VMEREADARRAY:DATA")
{
    field(DESC, "VMEReadArray data")
    field(DTYP, "asynInt32ArrayIn")
    field(INP,  "@asyn(icp,0,0)VMEREADARRAYDATA")
    field(NELM, "1024")
    field(FTVL, "ULONG")
}

## card_id, card_address, num_values, value1, value2, ...
record(waveform, "$(P)$(Q)VMEWRITEARRAY")
{
    field(DESC, "VMEWriteArray")
    field(NELM, "1027")
    field(FTVL, "ULONG")
    field(DTYP, "asynInt32ArrayOut")
    field(INP,  "@asyn(icp,0,0)VMEWRITEARRAY")
}

## card_id, card_address, num_values, trans_type
## trans_type is ored collection of ISISVME::TransferProp from isisicp
##   TransferNoOptions = 0x0, TransferBlock = 0x1, TransferLittleEndian = 0x2, 
##   TransferIORegisterSpace = 0x4, TransferLUTSpace = 0x8, TransferRunMemorySpace = 0x10, 
##   TransferAbsoluteAddress = 0x20
##   Each DAE3 card is treated as a DAE2 crate, each DAE3 module is like a DAE2 card.
##   The three modules share a registers IO space, some registers are present in all 3 modules at shifted addresses, 
##   some are only present once on DAU0. Specifying TransferAbsoluteAddress negates any module specific shifts. 
##   being applied to the io register read. 
##   TransferLittleEndian is only approariate for DAE2 detector card memory reads as is TransferBlock
record(waveform, "$(P)$(Q)QXREADARRAY:PROPS")
{
    field(DESC, "QXReadArray props")
    field(NELM, "4")
    field(FTVL, "LONG")
    field(DTYP, "asynInt32ArrayOut")
    field(INP,  "@asyn(icp,0,0)QXREADARRAYPROPS")
    field(FLNK,  "$(P)$(Q)QXREADARRAY:DATA")
}

## check NORD for how many read
record(waveform, "$(P)$(Q)QXREADARRAY:DATA")
{
    field(DESC, "QXReadArray data")
    field(DTYP, "asynInt32ArrayIn")
    field(INP,  "@asyn(icp,0,0)QXREADARRAYDATA")
    field(NELM, "1024")
    field(FTVL, "ULONG")
}

## card_id, card_address, num_values, transfer_type, value1, value2, ...
record(waveform, "$(P)$(Q)QXWRITEARRAY")
{
    field(DESC, "QXWriteArray")
    field(NELM, "1028")
    field(FTVL, "ULONG")
    field(DTYP, "asynInt32ArrayOut")
    field(INP,  "@asyn(icp,0,0)QXWRITEARRAY")
}
